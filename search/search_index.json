{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Developer's Guide  <p>Write your own ROAR apps for great good!</p> <p>The Rapid Online Assessment of Reading (ROAR) is an ongoing academic research project and online platform for assessing foundational reading skills. The ROAR is a suite of measures; each is delivered through the web browser and does not require a test administrator. The ROAR rapidly provides highly reliable indices of reading ability consistent with scores on other standardized reading assessments.</p> <p>This website serves as a development guide for researchers wishing to author their own ROAR applications. If you are an educator, clinician, student, or parent wishing to learn more about the ROAR, please visit the ROAR website.</p>"},{"location":"#features","title":"Features","text":"Write your assessments using jsPsych <p>ROAR apps use jsPsych to create browser-based cognitive and behavioral assessments. jsPsych has an extensive plugin environment to present stimuli and record responses. And if you can't find the plugin you need, you can browse an open repository of community contributed plugins, some of which were created at the  Brain Development and Education Lab.</p>  Easily write trial data to a Firestore database <p>ROAR apps write trial data to a Firestore database using the roar-firekit library. Trial data is written in real-time, so it's no problem if a participant quits in the middle of a run.  With offline data persistence, if your participant goes offline, your app will write trial data to a cache and synchronize changes to the database when the participant's device comes back online.</p>  Preview your app as you work <p>The built-in dev-server allows you to preview your ROAR assessment as you're writing it. It will even auto-reload and refresh your browser whenever you save your changes.</p>  Host anywhere <p>ROAR-apps build deployment files that you can host on GitHub pages, Amazon S3, Firebase hosting, or anywhere else else you choose.</p> <p>Developer's Guide</p>"},{"location":"about/contributing/","title":"Contributing to the ROAR development guide","text":"<p>Help make the development experience even better</p> <p>The ROAR development guide helps people develop their own web assessments using the ROAR framework. This page is about contributing directly to the development guide and the <code>create-roar-app</code> tempate.</p> <p>The ROAR project welcomes, and depends, on contributions from BDE Lab members and the broader web assessment community. Contributions can be made in a number of ways, a few examples are:</p> <ul> <li>Code patches via pull requests</li> <li>Documentation improvements</li> <li>Bug reports and patch reviews</li> <li>Development of new ROAR assessments</li> </ul> <p>Imposter's syndrome disclaimer<sup>1</sup></p> <p>We want your help. No, really.</p> <p>There may be a little voice inside your head that is telling you that you're not ready to be an open-source contributor; that your skills aren't nearly good enough to contribute. What could you possibly offer a project like this one?</p> <p>We assure you - the little voice in your head is wrong. If you can write code at all, you can contribute code to open-source. Contributing to open-source projects is a fantastic way to advance one's coding skills. Writing perfect code isn't the measure of a good developer (that would disqualify all of us!); it's trying to create something, making mistakes, and learning from those mistakes. That's how we all improve, and we are happy to help others learn.</p> <p>Being an open-source contributor doesn't just mean writing code, either. You can help out by writing documentation, tests, or even giving feedback about the project (and yes - that includes giving feedback about the contribution process). Some of these contributions may be the most valuable to the project as a whole, because you're coming to the project with fresh eyes, so you can see the errors and assumptions that seasoned contributors have glossed over.</p>"},{"location":"about/contributing/#practical-guide-to-submitting-your-contribution","title":"Practical guide to submitting your contribution","text":"<p>These guidelines are designed to make it as easy as possible to get involved. If you have any questions that aren't discussed below, please let us know by opening an issue!</p> <p>Before you start, you'll need to set up a free GitHub account and sign in. Here are some instructions.</p> <p>Already know what you're looking for in this guide? Jump to the following sections:</p> <ul> <li>Joining the conversation</li> <li>Contributing through GitHub</li> <li>Understanding GitHub issues</li> <li>Making a change</li> <li>Coding style</li> <li>Documentation</li> </ul>"},{"location":"about/contributing/#joining-the-conversation","title":"Joining the conversation","text":"<p>ROAR is primarily maintained by a collaborative research group. But we maintain this software as an open project. This means that we welcome contributions from people outside our group and we make sure to give contributors from outside our group credit in presentations of the work. In other words, we're excited to have you join! Most of our discussions will take place on open issues. We actively monitor this space and look forward to hearing from you!</p>"},{"location":"about/contributing/#contributing-through-github","title":"Contributing through GitHub","text":"<p>git is a really useful tool for version control. GitHub sits on top of git and supports collaborative and distributed working.</p> <p>If you're not yet familiar with git, there are lots of great resources to help you git started! Some of our favorites include the git Handbook and the Software Carpentry introduction to git.</p>"},{"location":"about/contributing/#writing-markdown","title":"Writing Markdown","text":"<p>On GitHub, you'll use Markdown to chat in issues and pull requests. You'll also use Markdown to contribute to the documentation in this developer's guide. You can think of Markdown as a few little symbols around your text that will render the text with a little bit of formatting. For example, you could write words as bold (<code>**bold**</code>), or in italics (<code>*italics*</code>), or as a link (<code>[link](https://youtu.be/dQw4w9WgXcQ)</code>) to another webpage.</p> <p>GitHub has a really helpful page for getting started with writing and formatting Markdown on GitHub.</p>"},{"location":"about/contributing/#understanding-github-issues","title":"Understanding GitHub issues","text":"<p>Every project on GitHub uses issues slightly differently. The following outlines how the ROAR developers think about these tools.</p> <p>Issues are individual pieces of work that need to be completed to move the project forward. A general guideline: if you find yourself tempted to write a great big issue that is difficult to be described as one unit of work, please consider splitting it into two or more issues.</p> <p>Issues are assigned labels which explain how they relate to the overall project's goals and immediate next steps.</p>"},{"location":"about/contributing/#issue-labels","title":"Issue Labels","text":"<p>The current list of issue labels are here and include:</p> <ul> <li> <p> These issues contain a task that is amenable to new contributors.</p> <p>If you feel that you can contribute to one of these issues, we especially encourage you to do so!</p> </li> <li> <p> These issues point to problems in the project.</p> <p>If you find new a bug, please give as much detail as possible in your issue, including steps to recreate the error. If you experience the same bug as one already listed, please add any additional information that you have as a comment.</p> </li> <li> <p> These issues are asking for new features and improvements to be considered by the project.</p> <p>Please try to make sure that your requested feature is distinct from any others that have already been requested or implemented. If you find one that's similar but there are subtle differences, please reference the other request in your issue.</p> </li> <li> <p> These issues are for improvements or additions to documentation.</p> <p>Writing documentation is one of the most important types of contributions that you can make. Good documentation helps users and developers, new and seasoned, in using and enhancing the ROAR ecosystem.</p> </li> </ul>"},{"location":"about/contributing/#making-a-change","title":"Making a change","text":"<p>We appreciate all contributions to ROAR, but those accepted fastest will follow a workflow similar to the following:</p> <ol> <li> <p>Comment on an existing issue or open a new issue referencing your addition.</p> <p>This allows other members of the ROAR development team to confirm that you aren't overlapping with work that's currently underway and that everyone is on the same page with the goal of the work you're going to carry out. This blog is a nice explanation of why putting this work in up front is so useful to everyone involved.</p> </li> <li> <p>Fork the ROAR repository to your profile.</p> <p>This is now your own unique copy of ROAR. Changes here won't effect anyone else's work, so it's a safe space to explore edits to the code! On your own fork of the repository, select Settings -&gt; Actions-&gt; \"Disable Actions for this repository\" to avoid flooding your inbox with warnings from our continuous integration suite.</p> </li> <li> <p>Clone your forked ROAR repository to your machine/computer.</p> <p>While you can edit files directly on github, sometimes the changes you want to make will be complex and you will want to use a text editor that you have installed on your local machine/computer. (One great text editor is vscode). In order to work on the code locally, you must clone your forked repository. To keep up with changes in the create-roar-app repository, add the \"upstream\" create-roar-app repository as a remote to your locally cloned repository.</p> <pre><code>git remote add upstream https://github.com/yeatmanlab/create-roar-app.git\n</code></pre> <p>Make sure to keep your fork up to date with the upstream repository. For example, to update your master branch on your local cloned repository:</p> <pre><code>git fetch upstream\ngit checkout master\ngit merge upstream/master\n</code></pre> </li> <li> <p>Create a new branch to develop and maintain the proposed code changes.</p> <p>For example:</p> <pre><code>git fetch upstream  # Always start with an updated upstream\ngit checkout -b fix/bug-1222 upstream/master\n</code></pre> <p>Please consider using appropriate branch names as those listed below, and mind that some of them are special (e.g., <code>doc/</code> and <code>docs/</code>):</p> <ul> <li><code>fix/&lt;some-identifier&gt;</code>: for bugfixes</li> <li><code>enh/&lt;feature-name&gt;</code>: for new features</li> <li><code>doc/&lt;some-identifier&gt;</code>: for documentation improvements.     You should name all your documentation branches with the prefix <code>doc/</code> or <code>docs/</code>     as that will preempt triggering the full battery of continuous integration tests.</li> </ul> </li> <li> <p>Make the changes you've discussed, following the ROAR coding style guide.</p> <p>Try to keep the changes focused: it is generally easy to review changes that address one feature or bug at a time. Once you are satisfied with your local changes, add/commit/push them to the branch on your forked repository.</p> </li> <li> <p>Submit a pull request.</p> <p>A member of the development team will review your changes to confirm that they can be merged into the main code base. Pull request titles should begin with a descriptive prefix (for example, <code>ENH: Adding another template</code>):</p> <ul> <li><code>ENH</code>: enhancements or new features</li> <li><code>FIX</code>: bug fixes</li> <li><code>TST</code>: new or updated tests</li> <li><code>DOC</code>: new or updated documentation</li> <li><code>STY</code>: style changes</li> <li><code>REF</code>: refactoring existing code</li> <li><code>CI</code>: updates to continous integration infrastructure</li> <li><code>MAINT</code>: general maintenance</li> <li>For works-in-progress, add the <code>WIP</code> tag in addition to the descriptive prefix.     Pull-requests tagged with <code>WIP:</code> will not be merged until the tag is removed.</li> </ul> </li> <li> <p>Have your PR reviewed by the development team, and update your changes accordingly in your branch.</p> <p>The reviewers will take special care in assisting you to address their comments, as well as dealing with conflicts and other tricky situations that could emerge from distributed development.</p> </li> </ol>"},{"location":"about/contributing/#roar-coding-style-guide","title":"ROAR coding style guide","text":"<p>Bug</p> <p>TODO: Fill this in with tslint and markdown lint information.</p>"},{"location":"about/contributing/#writing-documentation","title":"Writing documentation","text":"<p>Improving our documentation is often the most effective way to contribute to ROAR. This documentation guide is created using Material for MkDocs, which creates a website from a collection of Markdown files. There is an edit button displayed at the top of each document on this website. You may click that button to propose edits to any page. You can also fork and clone the entire repository as outlined above.</p> <ol> <li> <p>The imposter syndrome disclaimer was originally written by Adrienne Lowe for a PyCon talk, and was adapted based on its use in the README file for the MetPy project.\u00a0\u21a9</p> </li> </ol>"},{"location":"about/glossary/","title":"ROAR Glossary","text":"<p>Understanding ROAR terminology</p> <p>We try to use the following terms consistently to reduce confusion when talking about the different components of a ROAR app.</p> <ul> <li> <p>Trial</p> <p>A single stimulus/response pair</p> </li> <li> <p>Run</p> <p>A globally unique collection of successive trials that constitutes \"running\" through a ROAR assessment one time</p> </li> <li> <p>Corpus</p> <p>A named and immutable collection of stimuli</p> </li> <li> <p>Block</p> <p>A portion of a run whose stimuli are drawn from only one corpus ROAR assessments are usually broken up into blocks to give participants a bit of break.</p> </li> <li> <p>Task</p> <p>A ROAR assessment (e.g., ROAR-SWR, ROAR-MEP, etc.)</p> </li> <li> <p>Variant</p> <p>A variation of a ROAR assessment (e.g., adaptive vs. random)</p> </li> <li> <p>Study</p> <p>A collection of runs associated with a research project</p> </li> </ul>"},{"location":"about/license/","title":"License","text":"<p>The legal stuff.</p>"},{"location":"about/license/#included-projects","title":"Included projects","text":"<p>The <code>create-roar-app</code> program was initialized using <code>create-create-app</code>, which is licensed under the MIT License. The developer guide documentation was generated using MkDocs, which is released under the BSD-2-Clause License. Many thanks to the authors and contributors of these wonderful projects.</p>"},{"location":"about/license/#roar-licensing","title":"ROAR licensing","text":"<p>The <code>create-roar-app</code> program, associated documentation, and all ROAR assessments administered by Stanford's Brain Development and Education Lab (BDE Lab) are licensed under the Stanford Academic Software License For ROAR\u2122, the text of which is included below. If you are a member of the BDE Lab and are authoring a new ROAR assessment, you should also adopt the Stanford Academic Software License for ROAR\u2122, which is the default behavior of <code>create-roar-app</code>.</p>"},{"location":"about/license/#stanford-academic-software-license-for-roartm","title":"STANFORD ACADEMIC SOFTWARE LICENSE FOR ROAR\u2122","text":"<p>Stanford Docket S21-342: \"Rapid Online Assessment of Reading \"ROAR\u2122\")\"</p> <p>Please address any communications to: jyeatman@stanford.edu and otl@stanford.edu </p> <p>By accessing the software in this folder, you are agreeing to the license terms listed below.</p> <ol> <li>THE BOARD OF TRUSTEES OF THE LELAND STANFORD JUNIOR UNIVERSITY (\u201cStanford\u201d) has an assignment to \"Rapid Online Assessment of Reading (\"ROAR\u2122\")\" (\"Software\"), described in Stanford Docket S21-342, which was developed by Professor Jason Yeatman in the Graduate School of Education. </li> <li>By accessing, downloading, accepting, receiving, or using Software, including any accompanying information, materials or manuals you (\"RECIPIENT\") are agreeing to be bound by the terms of this License.  If you do not agree to the terms of this License, do not download any files from this directory.</li> <li>STANFORD grants to RECIPIENT a royalty-free, nonexclusive, and nontransferable license to use the Software furnished hereunder, upon the terms and conditions set out below. </li> <li>RECIPIENT acknowledges that the Software is a research tool still in the development stage and that it is being supplied as is, without any accompanying services, support or improvements from STANFORD.  STANFORD makes no representations and extends no warranties of any kind, either express or implied other than set out in this License.</li> <li>RECIPIENT agrees to use the Software solely for internal academic, non-commercial purposes and shall not distribute or transfer the Software or any of its derivatives or enhancements from RECIPIENT to another location or to any other person without prior written permission from STANFORD.</li> <li>RECIPIENT agrees not to reverse engineer, reverse assemble, reverse compile decompile, disassemble, or otherwise attempt to re-create the source code for the Software. RECIPIENT acknowledges that any programs created based on the Software will be considered a derivative of Software and owned by STANFORD. </li> <li>RECIPIENT may make modifications to the Software and integrate Software into RECIPIENT's own software.    All derivative works and enhancements are owned by Stanford.</li> <li>RECIPIENT may not further distribute Software or its derivatives or enhancements without express written permission of STANFORD. If permission to transfer the Software is given, RECIPIENT warrants that RECIPIENT will not remove or export any part of the Software from the United States except in full compliance with all United States export regulations and other applicable laws.</li> <li>RECIPIENT will use the Software in compliance with all applicable laws, policies and regulations including, but not limited to, any approvals, informed consent and patient confidentiality principles.</li> <li>RECIPIENT will indemnify, hold harmless, and defend STANFORD against any claim of any kind arising out of or related to the exercise of any rights granted under this License or the breach of this License by RECIPIENT.</li> <li>Title and copyright to the Software and any derivatives and any associated documentation shall at all times remain with STANFORD, and RECIPIENT agrees to preserve same.</li> <li>If RECIPIENT plans to publish any peer reviewed papers, abstracts, or similar publications, RECIPIENT agrees to acknowledge Software and its creator, Professor Jason Yeatman, in a manner consistent with academic (industry) practice. </li> <li>If RECIPIENT decides to terminate this License, RECIPIENT shall destroy or return immediately all Software and all derivative works.</li> </ol>"},{"location":"common-issues/asset-files/","title":"Advice for asset files","text":"<p>Adding asset files to ROAR experiments</p> <p>ROAR experiments can often include a lot of asset files, such as images, audio, and video. But as we include more asset files, our website becomes larger and this can affect application performance. It is therefore important to choose file formats that minimize file size while preserving quality. We recommend the following file formats and conversion tools:</p> Audio filesVideo filesImage files <p>Use the MP3 file format. We recommend using ffmpeg to convert your files to MP3. For example, to convert the file <code>sample.wav</code> to <code>sample.mp3</code>, use</p> <pre><code>ffmpeg -i sample.wav -codec:a libmp3lame -qscale:a 9 sample.mp3\n</code></pre> <p>The <code>-codec:a libmp3lame</code> option tells ffmpeg to use the LAME audio encoder and the <code>-qscale:a 9</code> option tells ffmpeg to reduce the audio quality in order to reduce file size. In our experience, you can be very aggressive in reducing the audio quality. But if you test out your audio and you aren't happy with the quality, you can always reduce the number that goes after <code>-qscale:a</code>.</p> <p>Use the MP4 file format. We recommend either ffmpeg or Handbrake for converting video files. Here is a nice article on using ffmpeg to convert media files. The specific options that you will need to convert videos depends on the input video format. So we recommend searching the web for best practices in converting your file format. For example, here is an article on converting AVI files to MP4. And here is one with a collection of commands for converting MOV files to MP4.</p> <p>If your image files are of geometric shapes (e.g. logos, icons, etc.), then we recommend using a vector graphic file format such as SVG or PDF. If your image file is a photograph, we recommend using a raster file format like JPEG or PNG. Try to strike a balance between image resolution and file size to save space in your web app.</p>"},{"location":"common-issues/audio-stimuli/","title":"Mobile-friendly audio","text":"<p>Special instructions for presenting audio stimuli</p> <p>In the previous sections of this guide, we used jsPsych's html-keyboard-response and image-keyboard-response plugins. If you have video stimuli, you could also use the video-keyboard-response plugin. Each of these plugins will work seemlessly on mobile and desktop web browsers. But if you're experiment involves audio stimuli, you will need to do a little bit of hacking to run your app on a mobile browser. In this section, we'll introduce the technique we've used to auto-play audio stimuli on mobile browsers.</p> Expand this to learn about other response modalities <p>All of the plugins listed above end in \"keyboard-response.\" jsPsych also allows other response modalities, like</p> <ul> <li>button response: html-button-response, image-button-response, video-button-response</li> <li>swipe response: html-swipe-response, image-swipe-response</li> <li>multi response (a combination of keyboard and button responses): html-multi-response, image-multi-response, video-multi-response</li> </ul> <p>And there are many more. Browse the list of official jsPsych plugins and the list of community contributed plugins.</p>"},{"location":"common-issues/audio-stimuli/#what-is-the-problem-with-audio-stimuli-on-ios","title":"What is the problem with audio stimuli on iOS","text":"<p>In most cases, playing audio files requires the use of the <code>&lt;audio&gt;</code> HTML tag or the JavaScript <code>Audio()</code> constuctor. jsPsych's audio stimulus plugins use these things under the hood. This works on desktop browsers but we want ROAR apps to be responsive to mobile platforms as well. On iOS platforms, autoplay is disabled. Instead, iOS requires that play be initiated as part of a user interaction (e.g., the user clicks a button). There's a bit of documentation about this on Apple's developer documentation. Practically speaking, this means that jsPsych's audio stimulus plugins, which autoplay audio immediately after a trial is loaded, will not work on iOS.</p>"},{"location":"common-issues/audio-stimuli/#what-is-the-recommended-solution","title":"What is the recommended solution","text":"<p>We can play audio using Javascript's <code>Audio()</code> constructor if we first ask the participant to click on a button. Moreover, once the participant clicks on a button the first time, we can preserve the original <code>Audio()</code> instance, change its <code>src</code> attribute to any other audio file, and call its <code>play()</code> method without any further user interaction. We'll step through this process below.</p> <ol> <li> <p>Hijack the enter-fullscreen button to play audio</p> <p>First we import the necessary files and setup our ROAR timeline as before. Then we import an inoffensive click sound (click.mp3) and create a global audio object (appropriately named <code>globalAudio</code>) to play this click sound. Lastly we add a fullscreen trial to the timeline and attach an <code>onclick</code> event to the fullscreen button to play the click sound. Here we use an event-related callback function to attach the <code>globalAudio</code>'s <code>play()</code> function to the fullscreen button's click event.</p> <pre><code>// Import jsPsych plugins as before\nimport jsPsychFullScreen from \"@jspsych/plugin-fullscreen\";\nimport jsPsychHtmlKeyboardResponse from \"@jspsych/plugin-html-keyboard-response\";\n\n// Import a click sound\nimport clickSound from '../assets/click.mp3';\n\n// Import an audio stimulus (we will use this in the next step)\nimport stimulusSound from '../assets/stimulus.mp3';\n\n// Import the ROAR setup functions as with the examples in the previous section.\nimport {\n  initConfig,\n  initRoarJsPsych,\n  initRoarTimeline,\n} from './config';  \n\n// Set up the config, jsPsych, and timeline just like before\nconst config = await initConfig();\nconst jsPsych = initRoarJsPsych(config);\nconst timeline = initRoarTimeline(config); \n\n// Here, create a global Audio object that will \"auto-play\" audio files\nconst globalAudio = new Audio(clickSound);\n\n// Use the standard enterFullscreen plugin as before\nconst enterFullscreen = {\n  type: jsPsychFullScreen,\n  fullscreen_mode: true,\n  message: `&lt;div&gt;&lt;h1&gt;The experiment will switch to full screen mode. &lt;br&gt; Click the button to continue. &lt;/h1&gt;&lt;/div&gt;`,\n  // But now we add an event related callback to play the click audio file once\n  // the user clicks the fullscreen button\n  on_load: () =&gt; {\n    const btn = document.getElementById('jspsych-fullscreen-btn');\n    btn.onclick = () =&gt; {\n      globalAudio.play();\n    }\n  }\n};\n\ntimeline.push(enterFullscreen);\n</code></pre> </li> <li> <p>Reuse the global audio object when we want to \"auto-play\" audio stimuli</p> <p>Okay, so we have just played an audio file in response to a user interaction, completely in compliance with the iOS developer constraints. In a sense, the user's initial button click on the fullscreen button has \"authorized\" the <code>globalAudio</code> object to play audio. Now we reuse the same <code>globalAudio</code> object to effectively auto-play new stimuli. Here we will use the <code>html-keyboard-response</code> plugin along with another event-related callback function to change the <code>src</code> attribute of the <code>globalAudio</code> object.</p> <pre><code>const audioStimulus = {\n  type: jsPsychHtmlKeyboardResponse,\n  // Once the trial loads, change the audio src to the desired\n  // stimulus and play the sound.\n  on_load: () =&gt; {\n    globalAudio.src = stimulusSound,\n    globalAudio.play();\n  },\n  stimulus: () =&gt; {\n    return `&lt;div&gt;\n      &lt;p&gt;This is the HTML that you would like to show on-screen while the audio stimulus plays.\n    &lt;/div&gt;`\n  },\n  // Arbitrary choices here. Replace with your own values.\n  choices = [\"a\", \"b\", \"c\"],\n  // Once the trial is finished, we pause the audio so that it doesn't\n  // \"play over\" into the next trail.\n  on_finish: () =&gt; {\n    globalAudio.pause();\n  },\n};\n\ntimeline.push(audioStimulus);\n</code></pre> </li> </ol> <p>Whew! Now we have audio stimuli that \"auto-play\" after a trial finishes loading.</p>"},{"location":"developer-guide/","title":"ROAR developer's guide","text":"<p>Write your own ROAR assessment</p> <p>The ROAR app development guide provides documentation for developers of ROAR assessments. The guide will take you step-by-step through the process of writing your own ROAR app in which participants will identify images representing hot dogs and \"not hot dogs.\" Please see the Contributing Guide for information on contributing to the create-roar-app initializer or to the developer guide itself. You can jump directly to a page listed below, or use the next and previous buttons in the navigation bar at the top of the page to move through the documentation in order.</p> <ul> <li>Prerequisites</li> <li>Installation</li> <li>Folder Structure</li> <li>Configuration</li> <li>Writing Your Experiment</li> <li>Installing Additional Dependencies</li> <li>Styling</li> <li>Deploying Your Experiment</li> <li>Retrieving Data</li> </ul> <p>You may also find it helpful to review some ROAR terminology. You can also browse the \"Common Issues\" section in the sidebar to the left to see solutions to common issues that ROAR developers face.</p> <p>This guide uses screencasts</p> <p>Throughout this guide, you will see screencasts like the one below</p> <p></p> <p>As mentioned in the screencast, you can copy text directly from the screencast. These screencasts are made using asciinema.</p> <p>In the screencasts, you might see us using the micro text editor. We chose that because it's a terminal-based text editor that plays nicely with the screencasting software that we use in this guide. You should use whatever text editor you are already comfortable with. If you don't already have a favorite text editor, we recommend  VS Code. </p>"},{"location":"developer-guide/configuration/","title":"Configuration (under the hood)","text":"<p>Communicate with the Firestore database and the participant dashboard.</p> <p>ROAR apps work in concert with the participant dashboard and the Firestore database to collect participant information and store trial data, respectively.</p> <p>The details of these interactions have been deliberately abstracted away from you and put \"under the hood\" in <code>src/config.js</code>. In this section, we will explain what you need to do to make your ROAR apps communicate with the dashboard and the database. We will also optionally dive deeper into <code>src/config.js</code> to gain an understanding of how this works.</p>"},{"location":"developer-guide/configuration/#communicate-with-the-dashboard","title":"Communicate with the dashboard","text":"<p>The participant dashboard provides a unified login experience and helps participants monitor their progress on multiple ROAR assessments. The dashboard keeps track of ROAR apps by assigned each one a unique number called a \"game token\". ROAR apps and the dashboard communicate with each other by passing parameters through the URL's query string. Suppose that your app is hosted at the website https://my-roar-app.web.app. The dashboard can be made to append a \"gameToken\" parameter. For example, https://my-roar-app.web.app?gameToken=1234 for the assessment associated with the game token \"1234\".</p> <p>You might be asking, \"what does my ROAR app do with this information?\" Well, when your assessment is done, it usually redirects the participant back to the dashboard. It has to let the dashboard know somehow that the participant has completed the game. ROAR apps solve this problem using the same query string technology, passing URL parameters for a game token, \"g\", and a completion status, \"c\". For example, redirecting the user to https://reading.stanford.edu/?g=1234&amp;c=1 would communicate to the dashboard that the participant has completed the game with game token 1234. If no game token URL parameter is given to a ROAR app, it's default behavior is to refresh the page after the assessment is done.</p> <p>What you need to do</p> <p>When you register your ROAR app in the participant dashboard, you must append a \"gameToken\" URL parameter. The value of this parameter must match the game token that the dashboard uses for your assessment.</p> Implementation details <p>There are lines of JavaScript code in <code>config.js</code> that inspect the \"gameToken\" parameter of the URL query string and construct the appropriate redirect URL to communicate back with the dashboard. You DO NOT need to edit this code.</p> src/config.js<pre><code>const queryString = new URL(window.location).search;\nconst urlParams = new URLSearchParams(queryString);\nconst gameToken = urlParams.get('gameToken') || null;\n\nconst redirect = () =&gt; {\n  if (gameToken === null) {\n    // If no game token was passed, we refresh the page rather than\n    // redirecting back to the dashboard\n    window.location.reload();\n  } else {\n    // Else, redirect back to the dashboard with the game token that\n    // was originally provided\n    window.location.href = `https://reading.stanford.edu/?g=${gameToken}&amp;c=1`;\n  }\n};\n</code></pre>"},{"location":"developer-guide/configuration/#keep-track-of-changes-to-your-task","title":"Keep track of changes to your task","text":"<p>During the installation phase, you entered some details about your task. We stored this metadata inside of <code>src/config.js</code> and it will be written to the Firestore database whenever a participant takes your assessment.</p> <p>This helps you keep track of which task your participant is taking. Furthermore, your ROAR app also keeps track of variations in your task by assigning a new variant every time you change your source code.</p> <p>What you need to do</p> <p>Nothing!</p> Implementation details <p>There are lines of JavaScript code in <code>config.js</code> that insert your task metadata into an object that is later passed to the Firestore database.</p> src/config.js<pre><code>function configTaskInfo() {\n  const taskInfo = {\n    taskId: 'my-roar-app',\n    taskName: 'My Roar App',\n    variantName: 'default',\n    taskDescription: 'An example ROAR app using the two-alternative forced choice template',\n    variantDescription: 'default',\n    // eslint-disable-next-line no-undef\n    srcHash: SRC_HASH,\n  };\n\n  return taskInfo;\n}\n</code></pre> <p>That <code>SRC_HASH</code> variable on line 19 contains a hash of your entire <code>src</code> directory. It is calculated in the <code>webpack.config.js</code> file and then inserted into your JavaScript files as a global variable every time you use <code>npm run build</code> or <code>npm start</code>.</p> webpack.config.js<pre><code>module.exports = async (env, args) =&gt; {\n  const hashOptions = {\n    folders: { exclude: ['.*', 'node_modules', 'test_coverage'] },\n    files: { include: ['*.js', '*.json'] },\n  };\n  const srcHash = await hashElement('./src', hashOptions);\n\n  const roarDbDoc = env.dbmode === 'production' ? 'production' : 'development';\n\n  let merged;\n  switch (args.mode) {\n    case 'development':\n      merged = merge(commonConfig, developmentConfig);\n      break;\n    case 'production':\n      merged = merge(commonConfig, productionConfig);\n      break;\n    default:\n      throw new Error('No matching configuration was found!');\n  }\n\n  return merge(\n    merged,\n    {\n      plugins: [\n        new HtmlWebpackPlugin({ title: 'My Roar App' }),\n        new webpack.ids.HashedModuleIdsPlugin(), // so that file hashes don't change unexpectedly\n        new webpack.DefinePlugin({\n          ROAR_DB_DOC: JSON.stringify(roarDbDoc),\n          SRC_HASH: JSON.stringify(srcHash),\n        }),\n      ],\n    },\n  );\n};\n</code></pre>"},{"location":"developer-guide/configuration/#connect-to-the-firestore-database","title":"Connect to the Firestore database","text":"<p>ROAR apps store each trial's data in a Firestore database. In order to communicate with Firebase, your app needs to know certain metadata about your Firebase project. If you are developing an app for the Brain Development and Education Lab (BDELab), then you don't have to do anything because the correct metadata has already been filled in. If you're developing for another organization, you'll have to supply your Firebase project configuration in the <code>src/firebaseConfig.js</code> file.</p> <p>The BDELab's Firestore database has separate collections for development and production data. So while you are developing your app, any trial data that you produce is kept separate from the experimental data of our in-production apps. Once you are ready to deploy your experiment in production, you're data will be stored in the production part of the database. By default, the development data will be stored in \"  dev  my-roar-app\", where the last element of that path will depend on the name that you gave to your ROAR app during installation. When deployed, your assessment data will be stored in \"  prod  roar-prod.\"</p> <p>What you need to do</p> <p>If you are storing your data in your own Firestore database, supply your Firebase project configuration in the <code>src/firebaseConfig.js</code> file. If you are developing for the BDELab, this step isn't necessary.</p> <p>To switch between the production and development portions of the database, use the <code>:prod</code> and <code>:dev</code> versions of the <code>npm run</code> commands. For example, <code>npm run build:dev</code> will build your app in the <code>dist</code> folder and configure it to store data in the development portion of the database. Conversely, <code>npm run build:prod</code> will configure it to write to the production portion of the database. There are similar sub-commands for <code>npm run start</code>.</p> <p>Lastly, if you type <code>npm start</code> or <code>npm run build</code> on their own without specifying <code>:prod</code> or <code>:dev</code>, the default behavior is to write to the development portion of the database.</p> Implementation details <p>The \"scripts\" portion of <code>package.json</code> contains the specialized <code>:prod</code> and <code>:dev</code> commands. Using <code>:prod</code> tells webpack to set the <code>dbmode</code> environment variable to \"production\", while using <code>:dev</code> sets that variable to \"development.\"</p> package.json<pre><code>  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",\n    \"build\": \"npx webpack --mode production\",\n    \"build:dev\": \"npm run build -- --env dbmode=development\",\n    \"build:prod\": \"npm run build -- --env dbmode=production\",\n    \"start\": \"npx webpack serve --open --mode development\",\n    \"start:dev\": \"npm run start -- --env dbmode=development\",\n    \"start:prod\": \"npm run start -- --env dbmode=production\"\n  },\n</code></pre> webpack.config.js<pre><code>module.exports = async (env, args) =&gt; {\n  const hashOptions = {\n    folders: { exclude: ['.*', 'node_modules', 'test_coverage'] },\n    files: { include: ['*.js', '*.json'] },\n  };\n  const srcHash = await hashElement('./src', hashOptions);\n\n  const roarDbDoc = env.dbmode === 'production' ? 'production' : 'development';\n\n  let merged;\n  switch (args.mode) {\n    case 'development':\n      merged = merge(commonConfig, developmentConfig);\n      break;\n    case 'production':\n      merged = merge(commonConfig, productionConfig);\n      break;\n    default:\n      throw new Error('No matching configuration was found!');\n  }\n\n  return merge(\n    merged,\n    {\n      plugins: [\n        new HtmlWebpackPlugin({ title: 'My Roar App' }),\n        new webpack.ids.HashedModuleIdsPlugin(), // so that file hashes don't change unexpectedly\n        new webpack.DefinePlugin({\n          ROAR_DB_DOC: JSON.stringify(roarDbDoc),\n          SRC_HASH: JSON.stringify(srcHash),\n        }),\n      ],\n    },\n  );\n};\n</code></pre> <p>The <code>ROAR_DB_DOC</code> global variable is then used inside of <code>src/firebaseConfig.js</code> to set the root document in Firestore.</p> src/firebaseConfig.js<pre><code>// eslint-disable-next-line no-undef\nconst prodDoc = 'your-org-name' === 'yeatmanlab' ? ['prod', 'roar-prod'] : ['external', 'your-org-name'];\n// eslint-disable-next-line no-undef\nconst rootDoc = ROAR_DB_DOC === 'production' ? prodDoc : ['dev', 'my-roar-app'];\n</code></pre>"},{"location":"developer-guide/configuration/#write-trial-data","title":"Write trial data","text":"<p>Now that the ROAR app is connected to the Firestore database, you're going to want to write some trial data to it. To do so, you MUST append a single <code>save_trial: true</code> field to the data collected by a jsPsych trial.</p> <p>What you need to do</p> <p>You MUST add specific data to any trial you want to save to the Firestore database. Here are instructions on how to add additional data to any jsPsych trial. In our case, we are required to add <code>save_trial: true</code> to the trial data. For example,</p> <pre><code>const trialSavedToFirestore{\n  type: jsPsychHtmlKeyboardResponse,\n  stimulus: \"Press y to save this trial to firestore\"\n  choices: ['y'],\n  // Here is where we specify that we should save the trial to Firestore\n  data: {\n    save_trial: true,\n  },\n},\n</code></pre> <p>In the template that we are using in this developer's guide, you can see that this is already done in <code>src/index.js</code> on lines 56-61.</p> Implementation details <p>In <code>src/config.js</code>, we added an event-related callback function to every single jsPsych trial. It gets called after the data gets updated and checks to see if the <code>save_trial</code> field is <code>true</code>. If so, it combines the trial data with some predefined timing and user data and writes it to the Firestore database using the roar-firekit library.</p> src/config.js<pre><code>jsPsych.opts.on_data_update = extend(jsPsych.opts.on_data_update, (data) =&gt; {\n  if (data.save_trial) {\n    config.firekit?.writeTrial({\n      timingData,\n      userInfo: config.firekit?.userInfo,\n      ...data,\n    });\n  }\n});\n</code></pre>"},{"location":"developer-guide/deploying-your-experiment/","title":"Deployment","text":"<p>Host your experiment on the web</p> <p>Bug</p> <p> You have reached a page that is under construction. Please be patient with us as we update the developer's guide.</p>"},{"location":"developer-guide/folder-structure/","title":"Folder Structure","text":"<p>Getting to know your project directory</p> <p>After creation, your project should look something like this:</p> <pre><code>my-roar-app\n\u251c\u2500\u2500 .eslintrc.json\n\u251c\u2500\u2500 .git/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 node_modules\n\u251c\u2500\u2500 package-lock.json\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 css/\n\u2502   \u2502   \u2514\u2500\u2500 roar.css\n\u2502   \u251c\u2500\u2500 config.js\n\u2502   \u251c\u2500\u2500 firebaseConfig.js\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 loadAssets.js\n\u2502   \u2514\u2500\u2500 logger.js\n\u2514\u2500\u2500 webpack.config.js\n</code></pre> <p>Folder contents may vary depending on which template you used. Here is a description of the various files in your project:</p>"},{"location":"developer-guide/folder-structure/#files-you-have-to-edit","title":"Files you have to edit","text":"<ul> <li> <p><code>src/index.js</code>:</p> <p>This file contains your experiments primary source code. See Writing Your Experiment for more details.</p> </li> <li> <p><code>src/loadAssets.js</code>:</p> <p>This file loads media, such as images, videos, and audio, that is needed for your stimuli. See Writing Your Experiment for further details.</p> </li> </ul>"},{"location":"developer-guide/folder-structure/#files-you-probably-should-edit","title":"Files you probably should edit","text":"<ul> <li> <p><code>README.md</code>:</p> <p>This file helps you communicate important information about your project. Read more about it here.</p> </li> </ul>"},{"location":"developer-guide/folder-structure/#files-you-may-edit-but-probably-wont-need-to","title":"Files you may edit but probably won't need to","text":"<ul> <li> <p><code>src/config.js</code>:</p> <p>This file contains experiment configuration details and code that helps your experiment communicate with the participant dashboard and the Firestore database. See Configuration for more details.</p> </li> <li> <p><code>src/firebaseConfig.js</code>:</p> <p>This file contains additional configuration information to help your app communicate with the Firestore database. See Configuration for more details.</p> </li> <li> <p><code>src/logger.js</code>:</p> <p>The JavaScript code in this file implements a logger to write debugging information to the console.</p> </li> <li> <p><code>src/css/roar.css</code>:</p> <p>This Cascading Style Sheet file describes how the HTML elements in your web experiement are to be displayed. See the styling section for more information on editing this file.</p> </li> <li> <p><code>.gitignore</code>:</p> <p>This file tells git which files and directories to ignore when you make commits. Read more in the Git Handbook. You might want to add to this file if you create new files in your applications folder but do not want to commit this to your git repository.</p> </li> <li> <p><code>.eslintrc.json</code>:</p> <p>Your new ROAR app uses ESLint to make your code more consistent and avoid bugs. This file is an ESLint configuration file that specified some of the options for ESLint. You should not have to edit this file.</p> </li> <li> <p><code>LICENSE</code>:</p> <p>The LICENSE file for your app. By default, all ROAR apps adopt the Stanford Academic Software License For ROAR\u2122. See the licensing page for more information.</p> </li> <li> <p><code>package.json</code>:</p> <p>This is npm's configuration file. Read more here. Among other things, it stores metadata about your project. It should be populated based on the answers you provided when creating your ROAR app. Usually, you won't need to edit this file. We recomment that you install dependencies using npm rather than editing this file directly.</p> </li> </ul>"},{"location":"developer-guide/folder-structure/#files-you-should-not-edit","title":"Files you should not edit","text":"<ul> <li> <p><code>.git/</code>:</p> <p>This folder contains all of the information that is necessary for version control of your project using git. This folders contents are explained in more detail in the git documentation. You do not need to understand, nor should you edit, the <code>.git</code> folder to create your ROAR app.</p> </li> <li> <p><code>node_modules</code>:</p> <p>Think of this as a cache for the external JavaScript modules/libraries that your ROAR app depends on. Do not edit this folder.</p> </li> <li> <p><code>package-lock.json</code>:</p> <p>This file specifies the exact dependency tree for your application. Find out more here. Do not edit this file.</p> </li> <li> <p><code>webpack.config.js</code>:</p> <p>Webpack is a \"module bundler.\" It takes your source code files and transforms them for deployment and usage in a web browser. The <code>webpack.config.js</code> file configures how webpack bundles your files. You do not need to understand how these files work in order to build your ROAR application.</p> </li> </ul>"},{"location":"developer-guide/folder-structure/#adding-and-removing-files","title":"Adding and removing files","text":"<p>For the project to build, you must have an <code>index.js</code> file in your <code>src</code> directory. If you know what you're doing, you can delete or rename the other files in <code>src</code>.</p> <p>You may create subdirectories inside <code>src</code>. For faster rebuilds, only files inside <code>src</code> are processed by webpack. You need to put any JS and CSS files inside <code>src</code>, otherwise webpack won\u2019t see them.</p> <p>You can create more top-level directories. They will not be included in the production build so you can use them for things like documentation or creation of custom stimuli.</p>"},{"location":"developer-guide/installation/","title":"ROAR App Installation","text":"<p>Use the create-roar-app template to create your app</p>"},{"location":"developer-guide/installation/#installation","title":"Installation","text":"<p>To create a new app, first navigate to the directory in which you want to store all of your ROAR assessments. For example</p> <pre><code>mkdir -p ~/roar-apps\ncd ~/roar-apps\n</code></pre> <p>You may then choose one of the following methods:</p> <p>Installation options</p> npx (recommended)npmyarn <pre><code>npx create-roar-app@latest my-roar-app\n</code></pre> <p>npx is a package runner tool that comes with npm 5.2+ and higher.</p> <pre><code>npm init roar-app@latest my-roar-app\n</code></pre> <p><code>npm init &lt;initializer&gt;</code> is available in npm 6+</p> <pre><code>yarn create roar-app@latest my-roar-app\n</code></pre> <p><code>yarn create &lt;starter-kit-package&gt;</code> is available in Yarn 0.25+</p> <p>Follow the on-screen prompts and answer questions about your application. Here's an example:</p> <p>This will create a directory called <code>my-roar-app</code> inside the current folder. Inside that directory, it will generate the initial project structure and install some  dependencies. Once the installation is done, you can navigate to your project folder:</p> <pre><code>cd my-roar-app\n</code></pre> <p>and make edits to your experiment's code. See the following pages for more detail:</p> <ul> <li>Configuration</li> <li>Writing Your Experiment</li> <li>Styling</li> </ul>"},{"location":"developer-guide/installation/#available-commands","title":"Available commands","text":"<p>Inside the newly created project, you can run some built-in commands:</p> <p>See a list of available commands</p> npmyarn <pre><code>npm run\n</code></pre> <pre><code>yarn run\n</code></pre> <p>Start a development server</p> npmyarn <pre><code>npm start\n</code></pre> <pre><code>yarn start\n</code></pre> <p>Runs the app in development mode. Visit http://localhost:8080 to view it in the browser.</p> <p>The page will automatically reload if you make changes to the code.</p> <p>We recommend using the Google Chrome browser for your web development. Use the Chrome DevTools to view your web application's DOM or debug your JavaScript.</p> <p>To stop the development server in your console, press Ctrl+C.</p> <p>Build your app for deployment</p> npmyarn <pre><code>npm run build\n</code></pre> <pre><code>yarn build\n</code></pre> <p>Builds the app for production to the <code>dist</code> folder. This correctly bundles your ROAR app in production mode and optimizes the build for the best performance.</p> <p>Your app is then ready to be deployed.</p> <p>There are other commands as well. The difference between <code>npm run build:dev</code> and <code>npm run build:prod</code>, for example, is explained in the Configuration section.</p>"},{"location":"developer-guide/installation/#make-your-first-commit","title":"Make your first commit","text":"<p>Before we start configuring your app, let's commit the files that the <code>create-roar-app</code> initializer created in your app directory.</p> screencastcode only <p> </p> <pre><code>git add .\ngit commit -m \"First commit. Add files created by the create-roar-app initializer\"\n</code></pre> <p>Now that you've committed the initial files, let's explore the folder we've created and start writing your experiment.</p>"},{"location":"developer-guide/installing-dependencies/","title":"Installing additional dependencies","text":"<p>Use external libraries to add functionality to your experiment</p> <p>As you develop your ROAR app, you may discover that you need to incorporate additional functionality using external JavaScript libraries. To do so, you'll follow outline of this section: installing the new library, importing it at the top of some JavaScript file, and using it in your source code. As a pedagogical example, in this section, we will install, import, and use the image-keyboard-response plugin.</p> <p>In the writing your experiment section, you added a block to your experiment asking participants to differentiate between cat and dog images. You may have noticed that we created the <code>block2Targets</code> array in <code>src/loadAssets.js</code> in order to pass an HTML string as a stimulus to the <code>jsPsychHtmlKeyboardResponse</code> plugin. But jsPsych already has its own <code>jsPsychImageKeyboardResponse</code> plugin that takes an image stimulus as input and obviates the need for creating the <code>block2Targets</code> array. In this section, we will install the <code>jsPsychImageKeyboardResponse</code> plugin and adapt your experiment to use it.</p> <p>Before we start, be sure to commit your work so far into version control.</p>"},{"location":"developer-guide/installing-dependencies/#installing-the-new-library","title":"Installing the new library","text":"<p>First, use either npm or yarn to install the new plugin</p> code onlyscreencast <p>Use either npm or yarn to install the new package</p> npm (recommended)yarn <pre><code>npm install @jspsych/plugin-image-keyboard-response\n</code></pre> <pre><code>yarn install @jspsych/plugin-image-button-response\n</code></pre> <p>You can then verify that <code>@jspsych/plugin-image-keyboard-response</code> has added to the dependencies section of the <code>package.json</code> file.</p> <p></p>"},{"location":"developer-guide/installing-dependencies/#importing-and-using-the-new-library","title":"Importing and using the new library","text":"<p>Now we are ready to start using the new plugin.</p> code onlyscreencast <p>First, remove the HTML image tag from the <code>allTargets</code> and <code>block2Targets</code> arrays in <code>src/loadAssets.js</code>:</p> src/loadAssets.js<pre><code>const allFiles = hotDogFiles.concat(notHotDogFiles);\nexport const allTargets = allFiles.map((url) =&gt; ({\n  target: url,\n  isHotDog: !url.includes('nothotdog'),\n}));\n\n/* preload images */\nexport const preloadImages = {\n  type: jsPsychPreload,\n  images: allFiles,\n};\n\nconst block2Files = catImages.concat(dogFiles);\nexport const block2Targets = block2Files.map((url) =&gt; ({\n  target: url,\n  isDog: url.includes('dog'),\n}));\n</code></pre> <p>Next, change import the new plugin type in <code>src/index.js</code>:</p> src/index.js<pre><code>// jsPsych imports\nimport jsPsychFullScreen from '@jspsych/plugin-fullscreen';\nimport jsPsychHtmlKeyboardResponse from '@jspsych/plugin-html-keyboard-response';\nimport jsPsychImageKeyboardResponse from '@jspsych/plugin-image-keyboard-response';\n</code></pre> <p>Later on, use this new plugin type in the <code>hotDogTrials</code> objects.</p> src/index.js<pre><code>const hotDogTrials = {\n  timeline: [\n    {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: '&lt;div style=\"font-size:60px;\"&gt;+&lt;/div&gt;',\n      choices: 'NO_KEYS',\n      trial_duration: 500,\n    },\n    {\n      // Here we change the plugin type\n      type: jsPsychImageKeyboardResponse,\n      stimulus: jsPsych.timelineVariable('target'),\n      choices: ['ArrowLeft', 'ArrowRight'],\n      prompt: `\n        &lt;p&gt;Is this a hot dog?&lt;/p&gt;\n        &lt;p&gt;If yes, press the right arrow key.&lt;/p&gt;\n        &lt;p&gt;If no, press the left arrow key.&lt;/p&gt;\n      `,\n      // And here we specify the stimulus height and width,\n      // which we previously did in the `allTargets` array.\n      stimulus_height: 250,\n      stimulus_width: 250,\n      data: {\n        // Here is where we specify that we should save the trial to Firestore\n        save_trial: true,\n        // Here we can also specify additional information that we would like stored\n        // in this trial in ROAR's Firestore database.\n      },\n    },\n  ],\n  timeline_variables: allTargets,\n  sample: {\n    type: 'without-replacement',\n    size: 10,\n  },\n};\n</code></pre> <p>And likewise for the <code>catDogTrials</code> object:</p> src/index.js<pre><code>const catDogTrials = {\n  timeline: [\n    {\n      type: jsPsychImageKeyboardResponse,\n      stimulus: '&lt;div style=\"font-size:60px;\"&gt;+&lt;/div&gt;',\n      choices: 'NO_KEYS',\n      trial_duration: 500,\n    },\n    {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: jsPsych.timelineVariable('target'),\n      choices: ['ArrowLeft', 'ArrowRight'],\n      prompt: `\n        &lt;p&gt;Is this a dog?&lt;/p&gt;\n        &lt;p&gt;If yes, press the right arrow key.&lt;/p&gt;\n        &lt;p&gt;If no, press the left arrow key.&lt;/p&gt;\n      `,\n      stimulus_height: 250,\n      stimulus_width: 250,\n      data: {\n        // Here is where we specify that we should save the trial to Firestore\n        save_trial: true,\n        // Here we can also specify additional information that we would like stored\n        // in this trial in ROAR's Firestore database.\n      },\n    },\n  ],\n  timeline_variables: block2Targets,\n  sample: {\n    type: 'without-replacement',\n    size: 10,\n  },\n};\n</code></pre> <p></p> <p>Congratulations! You just used your first new plugin type!</p>"},{"location":"developer-guide/prerequisites/","title":"ROAR development prerequisites","text":"<p>What do you need to get started?</p>"},{"location":"developer-guide/prerequisites/#prerequisite-knowledge","title":"Prerequisite knowledge","text":"<p>Before you start developing ROAR apps, it is helpful to have some knowledge of the topics listed below. Don't be intimidated if you're not familiar with some things.</p> <p>Imposter's Syndrome Disclaimer</p> <p>There may be a little voice inside your head that is telling you that you're not ready to develop a ROAR application; that your skills aren't nearly good enough to contribute. What could you possibly offer a project like this one?</p> <p>We assure you - the little voice in your head is wrong. If you can write at all, you can write a ROAR app. Creating your first web assessment is a fantastic way to advance one's coding skills. Writing perfect code isn't the measure of a good developer (that would disqualify all of us!); it's trying to create something, making mistakes, and learning from those mistakes.  That's how we all improve, and we are happy to help others learn.</p> <p>Here's what you need to know:</p> <ul> <li> <p> Familiarity with Javascript</p> <p>We will be developing your web assessment in JavaScript, a programming language that is one of the core technologies of the web. Web development with JavaScript can be efficient and fun! But teaching you JavaScript is beyond the scope of this guide. Instead, we recommend some the following resources:</p> <ul> <li>The Modern JavaScript Tutorial</li> <li>W3Schools JavaScript Tutorial</li> <li>MDN Web Docs for JavaScript</li> <li>JavaScript for Data Science</li> </ul> </li> <li> <p> Familiarity with jsPsych</p> <p>ROAR apps use jsPsych to create browser-based cognitive and behavioral assessments. jsPsych has some nice documentation to help you get started.</p> <p>From jsPsych's own documentation</p> <p>The page on timelines is a good place to start learning about jsPsych. From there, you might want to complete the hello world tutorial to learn how to set up a jsPsych experiment and the reaction time experiment tutorial to learn the core features of the framework.</p> </li> <li> <p> Familiarity with the command shell</p> <p>You will use the command shell to initialize your app and start your development server. We may use the words \"shell\", \"console\", \"bash\", or \"command prompt\" interchangeably. If you are new to the shell, we recommend the Software Carpentry introduction to the Unix shell.</p> </li> <li> <p> Some knowledge of git and GitHub</p> <p>git is a really useful tool for version control. GitHub sits on top of git and supports collaborative and distributed working.</p> <p>If you're not yet familiar with git, there are lots of great resources to help you git started! Some of our favorites include the git Handbook and the Software Carpentry introduction to git.</p> </li> </ul>"},{"location":"developer-guide/prerequisites/#software-prerequisites","title":"Software Prerequisites","text":"<p>In addition to the prerequisite knowledge above, you will need some software:</p> <ul> <li> <p> A command shell</p> <p>A shell is a program where users can type commands. The terms \"shell,\" \"command shell\", and \"terminal\" are used interchangeably throughout this guide. If you don't already have a command shell installed, you can follow these helpful instructions from The Carpentries to install the Bash shell. If you're not sure how to open a terminal on your operating system, see these instructions, also courtesy of The Carpentries.</p> </li> <li> <p> A text editor</p> <p>When you're writing code, it's nice to have a text editor that is optimized for writing code, with features like automatic color-coding of key words. The text editor that we recommend for ROAR development is  VS Code. For JavaScript development, you might also want to install these extensions</p> <ul> <li>JavaScript (ES6) code snippets</li> <li>ESLint</li> <li>Prettier</li> <li>Quokka.js</li> </ul> <p>The default text editor on macOS and Linux is usually set to Vim, which is not famous for being intuitive. If you accidentally find yourself stuck in it, hit the Esc key, followed by :+Q+! (colon, lower-case 'q', exclamation mark), then hitting Enter to return to the shell.</p> </li> <li> <p> node.js</p> <p>The ROAR development kit requires Node.js, a JavaScript runtime environment. Download and install Node.js here. You\u2019ll need to have Node 14.0.0 or later version on your local development machine. We recommend using the latest LTS version. You can use nvm (macOS/Linux) or nvm-windows to switch Node versions between different projects.</p> </li> <li> <p> git and a GitHub account</p> <p>Follow the Software Carpentry instructions for downloading Git.  You will also need an account at github.com. Basic GitHub accounts are free.</p> </li> </ul>"},{"location":"developer-guide/retrieving-data/","title":"Retrieving assessment data","text":"<p>How to query and retrieve experiment data</p> <p>Once you have deployed your experiment, you will want to retrieve its data to assess it's performance in evaluating your participants' abilities. You can view assessment data one trial at a time by browsing the Firestore database in your web browser or you can bulk download trial information using the roarquery tool.</p>"},{"location":"developer-guide/retrieving-data/#browsing-roar-data-online","title":"Browsing ROAR data online","text":"<p>You can browse your Firestore database's data online by navigating to the Cloud Firestore Data tab in your browser. From there, you can view, and query data. See this guide for more details on how to do that.</p>"},{"location":"developer-guide/retrieving-data/#retrieving-roar-data-from-the-command-line","title":"Retrieving ROAR data from the command line","text":"<p>The Firestore Data console is convenient for viewing a small number of database records at a time. But when you want to view or download many data records at a time, it is often easier to use a command line tool. For this reason, we created the roarquery command line tool. See the installation and authentication sections of the roarquery documentation to setup your roarquery tool. Then see the usage page to learn how to use roarquery to filter and retrieve a large number of ROAR trials.</p>"},{"location":"developer-guide/styling/","title":"Styling","text":"<p>Customizing the appearance of your experiment</p> <p>Bug</p> <p> You have reached a page that is under construction. Please be patient with us as we update the developer's guide.</p>"},{"location":"developer-guide/writing-your-experiment/","title":"Writing your experiment","text":"<p>Finally, let's stimulate our participant!</p>"},{"location":"developer-guide/writing-your-experiment/#starting-the-development-server","title":"Starting the development server","text":"<p>Your ROAR app is ready to go out of the box. Let's start the development server to see what the experiment looks like in the browser.</p> code onlyscreencast <pre><code>npm start\n</code></pre> <p></p> <p>This will automatically open a new browser tab with your experiment. It should look something like the experiment hosted here:</p> <p></p> <p>However, you're experiment will automatically update when you make changes to your source code.</p>"},{"location":"developer-guide/writing-your-experiment/#adding-another-block-of-stimuli","title":"Adding another block of stimuli","text":"<p>Let's pretend that we want to add a new block to our experiment where we ask the participant to further differentiate between cats and dogs. Let's implement that structure now by first adding images of cats and dogs and then editing the experiment's source code to include those new images.</p>"},{"location":"developer-guide/writing-your-experiment/#adding-more-images","title":"Adding more images","text":"<p>The first step in creating our new block is hosting the images of dogs and cats that we will use as stimuli. Download these images to your computer</p> <ul> <li>cat.zip</li> <li>dog.zip</li> </ul> <p>We will demonstrate two different ways to host images: we'll host the cat images along side your experiment and the dog images in a public google cloud storage bucket.</p>"},{"location":"developer-guide/writing-your-experiment/#hosting-images-alongside-your-experiment","title":"Hosting images alongside your experiment","text":"code onlyscreencast <p>First download the cat images zip file. Assuming that this file was downloaded to <code>~/Downloads</code>, do</p> <pre><code># Make a folder for the cat images\nmkdir -p src/assets\n# Navigate to that folder\ncd src/assets\n# Move the downloaded zip file to this folder\nmv ~/Downloads/cat.zip .\n# Unzip the file\nunzip cat.zip\n# And delete the zip file\nrm cat.zip\ncd ../..\n</code></pre> <p>Now edit the <code>src/loadAssets.js</code> file to load these new cat images. You can add individual files simply by importing them as variables and then referencing them in your code. For example</p> src/loadAssets.js<pre><code>import jsPsychPreload from '@jspsych/plugin-preload';\n\nimport cat1 from './assets/cat/1.jpg';\nimport cat2 from './assets/cat/2.jpg';\nimport cat3 from './assets/cat/3.jpg';\nimport cat4 from './assets/cat/4.jpg';\nimport cat5 from './assets/cat/5.jpg';\n\n// Reference these files in a new array\nconst catImages = [cat1, cat2, cat3, cat4, cat5];\n\n// Create arrays of hot dog / not hot dog images\nconst numFiles = 5;\nconst hotDogFiles = Array.from(Array(numFiles), (_, i) =&gt; i + 1).map(\n  (idx) =&gt; `https://storage.googleapis.com/roar-hot-dog-images/hotdog/${idx}.jpg`,\n);\n\nconst notHotDogFiles = Array.from(Array(numFiles), (_, i) =&gt; i + 1).map(\n  (idx) =&gt; `https://storage.googleapis.com/roar-hot-dog-images/nothotdog/${idx}.jpg`,\n);\n\nconst allFiles = hotDogFiles.concat(notHotDogFiles);\nexport const allTargets = allFiles.map((url) =&gt; ({\n  target: `&lt;img src=\"${url}\" width=250 height=250&gt;`,\n  isHotDog: !url.includes('nothotdog'),\n}));\n\n/* preload images */\nexport const preloadImages = {\n  type: jsPsychPreload,\n  images: allFiles,\n};\n\n// Preload the cat image\nexport const preloadCatImages = {\n  type: jsPsychPreload,\n  images: catImages,\n}\n</code></pre> <p>And don't forget to commit your changes into git.</p> <pre><code>git add src/assets/cat\ngit add -u\ngit commit -m \"Add cat images for block 2\"\n</code></pre> <p></p>"},{"location":"developer-guide/writing-your-experiment/#hosting-images-using-a-cloud-storage-provider","title":"Hosting images using a cloud storage provider","text":"<p>The above method of hosting image assets alongside your experiment is fine if you only have a few files. But it can become cumbersome to import each file separately if you have a lot of assets. Rather than hosting your files with your website, you can upload them to a cloud storage provider and access your files using a URL. To demonstrate, we have already uploaded the dog images to a Google Cloud Storage bucket. In fact, it is the same bucket that already hosts the hot dog vs. not hot dog images. You can see the images here (1, 2, 3, 4, 5).</p> <p>Two popular cloud storage service providers are Google Cloud Storage (GCS) and Amazon Simple Storage Service (S3). To upload your own images and make them publicly available, follow these instructions:</p> <ul> <li>Create a storage bucket (GCS instructions, S3 instructions)</li> <li>Upload objects to the bucket (GCS instructions, S3 instructions)</li> <li>Make the data public (GCS instructions, S3 instructions)</li> </ul> <p>Then we can add references to the dog image URLs like so</p> code onlyscreencast <p>Edit the <code>src/loadAssets.js</code> file to include the dog image URLs</p> src/loadAssets.js<pre><code>import jsPsychPreload from '@jspsych/plugin-preload';\n\nimport cat1 from './assets/cat/1.jpg';\nimport cat2 from './assets/cat/2.jpg';\nimport cat3 from './assets/cat/3.jpg';\nimport cat4 from './assets/cat/4.jpg';\nimport cat5 from './assets/cat/5.jpg';\n\n// Reference these files in a new array\nconst catImages = [cat1, cat2, cat3, cat4, cat5];\n\n// Create arrays of hot dog / not hot dog images\nconst numFiles = 5;\nconst hotDogFiles = Array.from(Array(numFiles), (_, i) =&gt; i + 1).map(\n  (idx) =&gt; `https://storage.googleapis.com/roar-hot-dog-images/hotdog/${idx}.jpg`,\n);\n\nconst notHotDogFiles = Array.from(Array(numFiles), (_, i) =&gt; i + 1).map(\n  (idx) =&gt; `https://storage.googleapis.com/roar-hot-dog-images/nothotdog/${idx}.jpg`,\n);\n\nconst dogFiles = Array.from(Array(numFiles), (_, i) =&gt; i + 1).map(\n  (idx) =&gt; `https://storage.googleapis.com/roar-hot-dog-images/dog/${idx}.jpg`,\n);\n\nconst allFiles = hotDogFiles.concat(notHotDogFiles);\nexport const allTargets = allFiles.map((url) =&gt; ({\n  target: `&lt;img src=\"${url}\" width=250 height=250&gt;`,\n  isHotDog: !url.includes('nothotdog'),\n}));\n\n/* preload images */\nexport const preloadImages = {\n  type: jsPsychPreload,\n  images: allFiles,\n};\n\nconst block2Files = catImages.concat(dogFiles);\nexport const block2Targets = block2Files.map((url) =&gt; ({\n  target: `&lt;img src=\"${url}\" width=250 height=250&gt;`,\n  isDog: url.includes('dog'),\n}));\n\n// Preload the cat/dog images\nexport const preloadBlock2Images = {\n  type: jsPsychPreload,\n  images: block2Files,\n};\n</code></pre> <p></p> Making sense of the above javascript <p>If the above line of javascript for <code>dogFiles</code> doesn't make sense to you, let's break it down into its components:</p> <pre><code>Array(numFiles)\n// Yields [ &lt;5 empty items&gt; ] since numFiles = 5\n\nArray.from(Array(numFiles), (_, i) =&gt; i + 1)\n// Yields [ 1, 2, 3, 4, 5 ]\n\n// And Finally\nArray.from(Array(numFiles), (_, i) =&gt; i + 1).map(\n  (idx) =&gt; `https://storage.googleapis.com/roar-hot-dog-images/dog/${idx}.jpg`,\n);\n// Yields\n// [\n//   'https://storage.googleapis.com/roar-hot-dog-images/dog/1.jpg',\n//   'https://storage.googleapis.com/roar-hot-dog-images/dog/2.jpg',\n//   'https://storage.googleapis.com/roar-hot-dog-images/dog/3.jpg',\n//   'https://storage.googleapis.com/roar-hot-dog-images/dog/4.jpg',\n//   'https://storage.googleapis.com/roar-hot-dog-images/dog/5.jpg'\n// ]\n</code></pre> <p>By using the map method, we were able to write the URL pattern just once, following the DRY principle. We use the map method again to convert the raw URLs in the <code>dogImages</code> array to HTML image tags in the <code>block2Targets</code> array.</p>"},{"location":"developer-guide/writing-your-experiment/#adding-a-block-of-stimuli-to-indexjs","title":"Adding a block of stimuli to <code>index.js</code>","text":"<p>Now that we have established references to our new cat vs. dog images, let's create the new block of stimuli. We'll introduce this first by adding only one single stimulus. and then we'll use the same code to add an entire block of stimuli using jsPsych's timeline variables.</p>"},{"location":"developer-guide/writing-your-experiment/#adding-a-single-stimulus","title":"Adding a single stimulus","text":"<p>We will add the first stimulus in the <code>block2Targets</code> array.</p> code onlyscreencast <p>Edit the <code>src/index.js</code> file to include a new instruction set and the new stimuli.</p> <p>At the top of the file, add the following imports</p> src/index.js<pre><code>// Local modules\nimport { initConfig, initRoarJsPsych, initRoarTimeline } from './config';\n\nimport { allTargets, preloadImages, block2Targets, preloadBlock2Images } from './loadAssets';\n</code></pre> <p>Then, a little bit later in the file, add</p> src/index.js<pre><code>timeline.push(hotDogTrials);\n\nconst block2Instructions = {\n  type: jsPsychHtmlKeyboardResponse,\n  stimulus: `\n    &lt;h3&gt;Great Job!&lt;/h3&gt;\n    &lt;p&gt;\n      Now press the right arrow key if the displayed image is of a dog.\n      Press the left arrow key if the displayed image is of a cat.\n    &lt;/p&gt;\n    &lt;p&gt;Press any key to continue.&lt;/p&gt;\n    `,\n};\n\ntimeline.push(preloadBlock2Images);\ntimeline.push(block2Instructions);\n\nconst catDogTrials = {\n  timeline: [\n    {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: `&lt;div style=\"font-size: 60px;\"&gt;+&lt;/div&gt;`,\n      choices: 'NO_KEYS',\n      trial_duration: 500,\n    },\n    {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: block2Targets[0].target,\n      choices: ['ArrowLeft', 'ArrowRight'],\n      prompt: `\n        &lt;p&gt;Is this a cat or a dog?&lt;/p&gt;\n        &lt;p&gt;If cat, press the left arrow key.&lt;/p&gt;\n        &lt;p&gt;If dog, press the right arrow key.&lt;/p&gt;\n        `\n      data: {\n        // Here is where we specify that we should save the trial to Firestore\n        save_trial: true,\n        // Here we can also specify additional information that we would like stored\n        // in this trial in ROAR's Firestore database.\n      },\n    }\n  ]\n};\n\ntimeline.push(catDogTrials);\n</code></pre> <p></p>"},{"location":"developer-guide/writing-your-experiment/#adding-a-block-of-stimuli","title":"Adding a block of stimuli","text":"<p>We just added one single stimulus. It would be really annoying to have to write all that code over and over just to add the next nine stimuli for this block. Luckily, jsPsych has timeline variables to make this easier. In fact, the hot dog vs. not hot dog block already uses this technology. Let's add the other dog vs. cat stimuli using timeline variables with random sampling.</p> code onlyscreencast <p>Edit the <code>catVsDogTrials</code> in the <code>src/index.js</code> file so that it reads:</p> src/index.js<pre><code>const catDogTrials = {\n  timeline: [\n    {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: `&lt;div style=\"font-size: 60px;\"&gt;+&lt;/div&gt;`,\n      choices: 'NO_KEYS',\n      trial_duration: 500,\n    },\n    {\n      type: jsPsychHtmlKeyboardResponse,\n      stimulus: jsPsych.timelineVariable('target'),\n      choices: ['ArrowLeft', 'ArrowRight'],\n      prompt: `\n        &lt;p&gt;Is this a cat or a dog?&lt;/p&gt;\n        &lt;p&gt;If cat, press the left arrow key.&lt;/p&gt;\n        &lt;p&gt;If dog, press the right arrow key.&lt;/p&gt;\n        `\n      data: {\n        // Here is where we specify that this trial is a test response trial\n        task: 'test_response',\n        // Here we can also specify additional information that we would like stored\n        // in this trial in ROAR's Firestore database. For example,\n        start_time: config.startTime.toLocaleString('PST'),\n        start_time_unix: config.startTime.getTime(),\n        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      }\n    }\n  ],\n  timeline_variables: block2Targets,\n  sample: {\n    type: 'without-replacement',\n    size: 10,\n  },\n};\n</code></pre> <p></p>"},{"location":"developer-guide/writing-your-experiment/#ending-the-experiment","title":"Ending the experiment","text":"<p>We've added the second block of stimuli. Right now, the experiment abruptly ends after the last stimulus. It's a good idea to let your participants know that they've finished the experiment. Let's add one last trial telling the participant that they are done.</p> code onlyscreencast <p>Add one more trial and push it to the timeline before the <code>exit_fullscreen</code> trial.</p> src/index.js<pre><code>const endTrial = {\n  type: jsPsychHtmlKeyboardResponse,\n  stimulus: '&lt;p&gt;Great job! Press any key to finish the assessment.&lt;/p&gt;',\n  choices: 'ALL_KEYS',\n  response_ends_trial: true,\n};\n\ntimeline.push(endTrial);\n\nconst exit_fullscreen = {\n  type: jsPsychFullScreen,\n  fullscreen_mode: false,\n  delay_after: 0,\n};\n\ntimeline.push(exit_fullscreen);\n</code></pre> <p></p> <p>How to properly end your assessment</p> <p>Be sure to give your participant concrete instructions for how to end the assessment. In this case, we told them to \"press any key to finish the assessment.\" If you don't, then the participant might think that they are done and simply close the browser tab. Why is this bad? Although all of the trial information will be saved in the database, the assessment will not be counted as finished (either in the database or in the participant dashboard) because the jsPsych timeline did not complete.</p> <p>If you want to use any of jsPsych's audio plugins (e.g., audio-button-response or audio-keyboard-response) to end the assessment be sure to specify <code>trial_ends_after_audio: true</code> so that the experiment automatically ends after the last audio file is played. Likewise, if you want to use any video plugins (e.g., video-button-response or video-keyboard-response), be sure to specify <code>trial_ends_after_video: true</code> so that the experiment automatically ends after the last video.</p> <p>The guiding principle here is to ensure that the jsPsych timeline ends before the participant closes their browser tab.</p>"},{"location":"developer-guide/writing-your-experiment/#advice-for-asset-files","title":"Advice for asset files","text":"<p>Please see Common Issues &gt; Advice For Asset Files.</p>"}]}