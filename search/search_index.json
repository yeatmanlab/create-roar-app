{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Developer's Guide Write your own ROAR apps for great good! The Rapid Online Assessment of Reading (ROAR) is an ongoing academic research project and online platform for assessing foundational reading skills. The ROAR is a suite of measures; each is delivered through the web browser and does not require a test administrator. The ROAR rapidly provides highly reliable indices of reading ability consistent with scores on other standardized reading assessments. This website serves as a development guide for researchers wishing to author their own ROAR applications. If you are an educator, clinician, student, or parent wishing to learn more about the ROAR, please visit the ROAR website . Features \u00b6 Write your assessments using jsPsych ROAR apps use jsPsych to create browser-based cognitive and behavioral assessments. jsPsych has an extensive plugin environment to present stimuli and record responses. And if you can't find the plugin you need, you can browse an open repository of community contributed plugins , some of which were created at the Brain Development and Education Lab . Easily write trial data to a Firestore database ROAR apps write trial data to a Firestore database using the roar-firekit library. Trial data is written in real-time, so it's no problem if a participant quits in the middle of a run. With offline data persistence, if your participant goes offline, your app will write trial data to a cache and synchronize changes to the database when the participant's device comes back online. Preview your app as you work The built-in dev-server allows you to preview your ROAR assessment as you're writing it. It will even auto-reload and refresh your browser whenever you save your changes. Host anywhere ROAR-apps build deployment files that you can host on GitHub pages, Amazon S3, Firebase hosting, or anywhere else else you choose. Developer's Guide","title":"Home"},{"location":"#features","text":"Write your assessments using jsPsych ROAR apps use jsPsych to create browser-based cognitive and behavioral assessments. jsPsych has an extensive plugin environment to present stimuli and record responses. And if you can't find the plugin you need, you can browse an open repository of community contributed plugins , some of which were created at the Brain Development and Education Lab . Easily write trial data to a Firestore database ROAR apps write trial data to a Firestore database using the roar-firekit library. Trial data is written in real-time, so it's no problem if a participant quits in the middle of a run. With offline data persistence, if your participant goes offline, your app will write trial data to a cache and synchronize changes to the database when the participant's device comes back online. Preview your app as you work The built-in dev-server allows you to preview your ROAR assessment as you're writing it. It will even auto-reload and refresh your browser whenever you save your changes. Host anywhere ROAR-apps build deployment files that you can host on GitHub pages, Amazon S3, Firebase hosting, or anywhere else else you choose. Developer's Guide","title":"Features"},{"location":"about/contributing/","text":"Contributing to the ROAR development guide \u00b6 Help make the development experience even better The ROAR development guide helps people develop their own web assessments using the ROAR framework. This page is about contributing directly to the development guide and the create-roar-app tempate. The ROAR project welcomes, and depends, on contributions from BDE Lab members and the broader web assessment community. Contributions can be made in a number of ways, a few examples are: Code patches via pull requests Documentation improvements Bug reports and patch reviews Development of new ROAR assessments Imposter's syndrome disclaimer 1 We want your help. No, really. There may be a little voice inside your head that is telling you that you're not ready to be an open-source contributor; that your skills aren't nearly good enough to contribute. What could you possibly offer a project like this one? We assure you - the little voice in your head is wrong. If you can write code at all, you can contribute code to open-source. Contributing to open-source projects is a fantastic way to advance one's coding skills. Writing perfect code isn't the measure of a good developer (that would disqualify all of us!); it's trying to create something, making mistakes, and learning from those mistakes. That's how we all improve, and we are happy to help others learn. Being an open-source contributor doesn't just mean writing code, either. You can help out by writing documentation, tests, or even giving feedback about the project (and yes - that includes giving feedback about the contribution process). Some of these contributions may be the most valuable to the project as a whole, because you're coming to the project with fresh eyes, so you can see the errors and assumptions that seasoned contributors have glossed over. Practical guide to submitting your contribution \u00b6 These guidelines are designed to make it as easy as possible to get involved. If you have any questions that aren't discussed below, please let us know by opening an issue ! Before you start, you'll need to set up a free GitHub account and sign in. Here are some instructions . Already know what you're looking for in this guide? Jump to the following sections: Joining the conversation Contributing through GitHub Understanding GitHub issues Making a change Coding style Documentation Joining the conversation \u00b6 ROAR is primarily maintained by a collaborative research group . But we maintain this software as an open project. This means that we welcome contributions from people outside our group and we make sure to give contributors from outside our group credit in presentations of the work. In other words, we're excited to have you join! Most of our discussions will take place on open issues . We actively monitor this space and look forward to hearing from you! Contributing through GitHub \u00b6 git is a really useful tool for version control. GitHub sits on top of git and supports collaborative and distributed working. If you're not yet familiar with git, there are lots of great resources to help you git started! Some of our favorites include the git Handbook and the Software Carpentry introduction to git . Writing Markdown \u00b6 On GitHub, you'll use Markdown to chat in issues and pull requests. You'll also use Markdown to contribute to the documentation in this developer's guide. You can think of Markdown as a few little symbols around your text that will render the text with a little bit of formatting. For example, you could write words as bold ( **bold** ), or in italics ( *italics* ), or as a link ( [link](https://youtu.be/dQw4w9WgXcQ) ) to another webpage. GitHub has a really helpful page for getting started with writing and formatting Markdown on GitHub . Understanding GitHub issues \u00b6 Every project on GitHub uses issues slightly differently. The following outlines how the ROAR developers think about these tools. Issues are individual pieces of work that need to be completed to move the project forward. A general guideline: if you find yourself tempted to write a great big issue that is difficult to be described as one unit of work, please consider splitting it into two or more issues. Issues are assigned labels which explain how they relate to the overall project's goals and immediate next steps. Issue Labels \u00b6 The current list of issue labels are here and include: These issues contain a task that is amenable to new contributors. If you feel that you can contribute to one of these issues, we especially encourage you to do so! These issues point to problems in the project. If you find new a bug, please give as much detail as possible in your issue, including steps to recreate the error. If you experience the same bug as one already listed, please add any additional information that you have as a comment. These issues are asking for new features and improvements to be considered by the project. Please try to make sure that your requested feature is distinct from any others that have already been requested or implemented. If you find one that's similar but there are subtle differences, please reference the other request in your issue. These issues are for improvements or additions to documentation. Writing documentation is one of the most important types of contributions that you can make. Good documentation helps users and developers, new and seasoned, in using and enhancing the ROAR ecosystem. Making a change \u00b6 We appreciate all contributions to ROAR , but those accepted fastest will follow a workflow similar to the following: Comment on an existing issue or open a new issue referencing your addition. This allows other members of the ROAR development team to confirm that you aren't overlapping with work that's currently underway and that everyone is on the same page with the goal of the work you're going to carry out. This blog is a nice explanation of why putting this work in up front is so useful to everyone involved. Fork the ROAR repository to your profile. This is now your own unique copy of ROAR . Changes here won't effect anyone else's work, so it's a safe space to explore edits to the code! On your own fork of the repository, select Settings -> Actions-> \"Disable Actions for this repository\" to avoid flooding your inbox with warnings from our continuous integration suite. Clone your forked ROAR repository to your machine/computer. While you can edit files directly on github , sometimes the changes you want to make will be complex and you will want to use a text editor that you have installed on your local machine/computer. (One great text editor is vscode ). In order to work on the code locally, you must clone your forked repository. To keep up with changes in the create-roar-app repository, add the \"upstream\" create-roar-app repository as a remote to your locally cloned repository. git remote add upstream https://github.com/yeatmanlab/create-roar-app.git Make sure to keep your fork up to date with the upstream repository. For example, to update your master branch on your local cloned repository: git fetch upstream git checkout master git merge upstream/master Create a new branch to develop and maintain the proposed code changes. For example: git fetch upstream # Always start with an updated upstream git checkout -b fix/bug-1222 upstream/master Please consider using appropriate branch names as those listed below, and mind that some of them are special (e.g., doc/ and docs/ ): fix/<some-identifier> : for bugfixes enh/<feature-name> : for new features doc/<some-identifier> : for documentation improvements. You should name all your documentation branches with the prefix doc/ or docs/ as that will preempt triggering the full battery of continuous integration tests. Make the changes you've discussed, following the ROAR coding style guide . Try to keep the changes focused: it is generally easy to review changes that address one feature or bug at a time. Once you are satisfied with your local changes, add/commit/push them to the branch on your forked repository. Submit a pull request . A member of the development team will review your changes to confirm that they can be merged into the main code base. Pull request titles should begin with a descriptive prefix (for example, ENH: Adding another template ): ENH : enhancements or new features FIX : bug fixes TST : new or updated tests DOC : new or updated documentation STY : style changes REF : refactoring existing code CI : updates to continous integration infrastructure MAINT : general maintenance For works-in-progress, add the WIP tag in addition to the descriptive prefix. Pull-requests tagged with WIP: will not be merged until the tag is removed. Have your PR reviewed by the development team, and update your changes accordingly in your branch. The reviewers will take special care in assisting you to address their comments, as well as dealing with conflicts and other tricky situations that could emerge from distributed development. ROAR coding style guide \u00b6 Bug TODO: Fill this in with tslint and markdown lint information. Writing documentation \u00b6 Improving our documentation is often the most effective way to contribute to ROAR. This documentation guide is created using Material for MkDocs , which creates a website from a collection of Markdown files. There is an edit button displayed at the top of each document on this website. You may click that button to propose edits to any page. You can also fork and clone the entire repository as outlined above. The imposter syndrome disclaimer was originally written by Adrienne Lowe for a PyCon talk , and was adapted based on its use in the README file for the MetPy project . \u21a9","title":"Contributing"},{"location":"about/contributing/#contributing-to-the-roar-development-guide","text":"Help make the development experience even better The ROAR development guide helps people develop their own web assessments using the ROAR framework. This page is about contributing directly to the development guide and the create-roar-app tempate. The ROAR project welcomes, and depends, on contributions from BDE Lab members and the broader web assessment community. Contributions can be made in a number of ways, a few examples are: Code patches via pull requests Documentation improvements Bug reports and patch reviews Development of new ROAR assessments Imposter's syndrome disclaimer 1 We want your help. No, really. There may be a little voice inside your head that is telling you that you're not ready to be an open-source contributor; that your skills aren't nearly good enough to contribute. What could you possibly offer a project like this one? We assure you - the little voice in your head is wrong. If you can write code at all, you can contribute code to open-source. Contributing to open-source projects is a fantastic way to advance one's coding skills. Writing perfect code isn't the measure of a good developer (that would disqualify all of us!); it's trying to create something, making mistakes, and learning from those mistakes. That's how we all improve, and we are happy to help others learn. Being an open-source contributor doesn't just mean writing code, either. You can help out by writing documentation, tests, or even giving feedback about the project (and yes - that includes giving feedback about the contribution process). Some of these contributions may be the most valuable to the project as a whole, because you're coming to the project with fresh eyes, so you can see the errors and assumptions that seasoned contributors have glossed over.","title":"Contributing to the ROAR development guide"},{"location":"about/contributing/#practical-guide-to-submitting-your-contribution","text":"These guidelines are designed to make it as easy as possible to get involved. If you have any questions that aren't discussed below, please let us know by opening an issue ! Before you start, you'll need to set up a free GitHub account and sign in. Here are some instructions . Already know what you're looking for in this guide? Jump to the following sections: Joining the conversation Contributing through GitHub Understanding GitHub issues Making a change Coding style Documentation","title":"Practical guide to submitting your contribution"},{"location":"about/contributing/#joining-the-conversation","text":"ROAR is primarily maintained by a collaborative research group . But we maintain this software as an open project. This means that we welcome contributions from people outside our group and we make sure to give contributors from outside our group credit in presentations of the work. In other words, we're excited to have you join! Most of our discussions will take place on open issues . We actively monitor this space and look forward to hearing from you!","title":"Joining the conversation"},{"location":"about/contributing/#contributing-through-github","text":"git is a really useful tool for version control. GitHub sits on top of git and supports collaborative and distributed working. If you're not yet familiar with git, there are lots of great resources to help you git started! Some of our favorites include the git Handbook and the Software Carpentry introduction to git .","title":"Contributing through GitHub"},{"location":"about/contributing/#writing-markdown","text":"On GitHub, you'll use Markdown to chat in issues and pull requests. You'll also use Markdown to contribute to the documentation in this developer's guide. You can think of Markdown as a few little symbols around your text that will render the text with a little bit of formatting. For example, you could write words as bold ( **bold** ), or in italics ( *italics* ), or as a link ( [link](https://youtu.be/dQw4w9WgXcQ) ) to another webpage. GitHub has a really helpful page for getting started with writing and formatting Markdown on GitHub .","title":"Writing Markdown"},{"location":"about/contributing/#understanding-github-issues","text":"Every project on GitHub uses issues slightly differently. The following outlines how the ROAR developers think about these tools. Issues are individual pieces of work that need to be completed to move the project forward. A general guideline: if you find yourself tempted to write a great big issue that is difficult to be described as one unit of work, please consider splitting it into two or more issues. Issues are assigned labels which explain how they relate to the overall project's goals and immediate next steps.","title":"Understanding GitHub issues"},{"location":"about/contributing/#issue-labels","text":"The current list of issue labels are here and include: These issues contain a task that is amenable to new contributors. If you feel that you can contribute to one of these issues, we especially encourage you to do so! These issues point to problems in the project. If you find new a bug, please give as much detail as possible in your issue, including steps to recreate the error. If you experience the same bug as one already listed, please add any additional information that you have as a comment. These issues are asking for new features and improvements to be considered by the project. Please try to make sure that your requested feature is distinct from any others that have already been requested or implemented. If you find one that's similar but there are subtle differences, please reference the other request in your issue. These issues are for improvements or additions to documentation. Writing documentation is one of the most important types of contributions that you can make. Good documentation helps users and developers, new and seasoned, in using and enhancing the ROAR ecosystem.","title":"Issue Labels"},{"location":"about/contributing/#making-a-change","text":"We appreciate all contributions to ROAR , but those accepted fastest will follow a workflow similar to the following: Comment on an existing issue or open a new issue referencing your addition. This allows other members of the ROAR development team to confirm that you aren't overlapping with work that's currently underway and that everyone is on the same page with the goal of the work you're going to carry out. This blog is a nice explanation of why putting this work in up front is so useful to everyone involved. Fork the ROAR repository to your profile. This is now your own unique copy of ROAR . Changes here won't effect anyone else's work, so it's a safe space to explore edits to the code! On your own fork of the repository, select Settings -> Actions-> \"Disable Actions for this repository\" to avoid flooding your inbox with warnings from our continuous integration suite. Clone your forked ROAR repository to your machine/computer. While you can edit files directly on github , sometimes the changes you want to make will be complex and you will want to use a text editor that you have installed on your local machine/computer. (One great text editor is vscode ). In order to work on the code locally, you must clone your forked repository. To keep up with changes in the create-roar-app repository, add the \"upstream\" create-roar-app repository as a remote to your locally cloned repository. git remote add upstream https://github.com/yeatmanlab/create-roar-app.git Make sure to keep your fork up to date with the upstream repository. For example, to update your master branch on your local cloned repository: git fetch upstream git checkout master git merge upstream/master Create a new branch to develop and maintain the proposed code changes. For example: git fetch upstream # Always start with an updated upstream git checkout -b fix/bug-1222 upstream/master Please consider using appropriate branch names as those listed below, and mind that some of them are special (e.g., doc/ and docs/ ): fix/<some-identifier> : for bugfixes enh/<feature-name> : for new features doc/<some-identifier> : for documentation improvements. You should name all your documentation branches with the prefix doc/ or docs/ as that will preempt triggering the full battery of continuous integration tests. Make the changes you've discussed, following the ROAR coding style guide . Try to keep the changes focused: it is generally easy to review changes that address one feature or bug at a time. Once you are satisfied with your local changes, add/commit/push them to the branch on your forked repository. Submit a pull request . A member of the development team will review your changes to confirm that they can be merged into the main code base. Pull request titles should begin with a descriptive prefix (for example, ENH: Adding another template ): ENH : enhancements or new features FIX : bug fixes TST : new or updated tests DOC : new or updated documentation STY : style changes REF : refactoring existing code CI : updates to continous integration infrastructure MAINT : general maintenance For works-in-progress, add the WIP tag in addition to the descriptive prefix. Pull-requests tagged with WIP: will not be merged until the tag is removed. Have your PR reviewed by the development team, and update your changes accordingly in your branch. The reviewers will take special care in assisting you to address their comments, as well as dealing with conflicts and other tricky situations that could emerge from distributed development.","title":"Making a change"},{"location":"about/contributing/#roar-coding-style-guide","text":"Bug TODO: Fill this in with tslint and markdown lint information.","title":"ROAR coding style guide"},{"location":"about/contributing/#writing-documentation","text":"Improving our documentation is often the most effective way to contribute to ROAR. This documentation guide is created using Material for MkDocs , which creates a website from a collection of Markdown files. There is an edit button displayed at the top of each document on this website. You may click that button to propose edits to any page. You can also fork and clone the entire repository as outlined above. The imposter syndrome disclaimer was originally written by Adrienne Lowe for a PyCon talk , and was adapted based on its use in the README file for the MetPy project . \u21a9","title":"Writing documentation"},{"location":"about/glossary/","text":"ROAR Glossary \u00b6 Understanding ROAR terminology We try to use the following terms consistently to reduce confusion when talking about the different components of a ROAR app. Trial A single stimulus/response pair Run A globally unique collection of successive trials that constitutes \"running\" through a ROAR assessment one time Corpus A named and immutable collection of stimuli Block A portion of a run whose stimuli are drawn from only one corpus ROAR assessments are usually broken up into blocks to give participants a bit of break. Task A ROAR assessment (e.g., ROAR-SWR, ROAR-MEP, etc.) Variant A variation of a ROAR assessment (e.g., adaptive vs. random) Study A collection of runs associated with a research project","title":"Glossary"},{"location":"about/glossary/#roar-glossary","text":"Understanding ROAR terminology We try to use the following terms consistently to reduce confusion when talking about the different components of a ROAR app. Trial A single stimulus/response pair Run A globally unique collection of successive trials that constitutes \"running\" through a ROAR assessment one time Corpus A named and immutable collection of stimuli Block A portion of a run whose stimuli are drawn from only one corpus ROAR assessments are usually broken up into blocks to give participants a bit of break. Task A ROAR assessment (e.g., ROAR-SWR, ROAR-MEP, etc.) Variant A variation of a ROAR assessment (e.g., adaptive vs. random) Study A collection of runs associated with a research project","title":"ROAR Glossary"},{"location":"about/license/","text":"License \u00b6 The legal stuff. Included projects \u00b6 The create-roar-app program was initialized using create-create-app , which is licensed under the MIT License . The developer guide documentation was generated using MkDocs, which is released under the BSD-2-Clause License . Many thanks to the authors and contributors of these wonderful projects. ROAR licensing \u00b6 The create-roar-app program, associated documentation, and all ROAR assessments administered by Stanford's Brain Development and Education Lab (BDE Lab) are licensed under the Stanford Academic Software License For ROAR\u2122, the text of which is included below. If you are a member of the BDE Lab and are authoring a new ROAR assessment, you should also adopt the Stanford Academic Software License for ROAR\u2122, which is the default behavior of create-roar-app . STANFORD ACADEMIC SOFTWARE LICENSE FOR ROAR\u2122 \u00b6 Stanford Docket S21-342: \"Rapid Online Assessment of Reading \"ROAR\u2122\")\" Please address any communications to: jyeatman@stanford.edu and otl@stanford.edu By accessing the software in this folder, you are agreeing to the license terms listed below. THE BOARD OF TRUSTEES OF THE LELAND STANFORD JUNIOR UNIVERSITY (\u201cStanford\u201d) has an assignment to \"Rapid Online Assessment of Reading (\"ROAR\u2122\")\" (\"Software\"), described in Stanford Docket S21-342, which was developed by Professor Jason Yeatman in the Graduate School of Education. By accessing, downloading, accepting, receiving, or using Software, including any accompanying information, materials or manuals you (\"RECIPIENT\") are agreeing to be bound by the terms of this License. If you do not agree to the terms of this License, do not download any files from this directory. STANFORD grants to RECIPIENT a royalty-free, nonexclusive, and nontransferable license to use the Software furnished hereunder, upon the terms and conditions set out below. RECIPIENT acknowledges that the Software is a research tool still in the development stage and that it is being supplied as is, without any accompanying services, support or improvements from STANFORD. STANFORD makes no representations and extends no warranties of any kind, either express or implied other than set out in this License. RECIPIENT agrees to use the Software solely for internal academic, non-commercial purposes and shall not distribute or transfer the Software or any of its derivatives or enhancements from RECIPIENT to another location or to any other person without prior written permission from STANFORD. RECIPIENT agrees not to reverse engineer, reverse assemble, reverse compile decompile, disassemble, or otherwise attempt to re-create the source code for the Software. RECIPIENT acknowledges that any programs created based on the Software will be considered a derivative of Software and owned by STANFORD. RECIPIENT may make modifications to the Software and integrate Software into RECIPIENT's own software. All derivative works and enhancements are owned by Stanford. RECIPIENT may not further distribute Software or its derivatives or enhancements without express written permission of STANFORD. If permission to transfer the Software is given, RECIPIENT warrants that RECIPIENT will not remove or export any part of the Software from the United States except in full compliance with all United States export regulations and other applicable laws. RECIPIENT will use the Software in compliance with all applicable laws, policies and regulations including, but not limited to, any approvals, informed consent and patient confidentiality principles. RECIPIENT will indemnify, hold harmless, and defend STANFORD against any claim of any kind arising out of or related to the exercise of any rights granted under this License or the breach of this License by RECIPIENT. Title and copyright to the Software and any derivatives and any associated documentation shall at all times remain with STANFORD, and RECIPIENT agrees to preserve same. If RECIPIENT plans to publish any peer reviewed papers, abstracts, or similar publications, RECIPIENT agrees to acknowledge Software and its creator, Professor Jason Yeatman, in a manner consistent with academic (industry) practice. If RECIPIENT decides to terminate this License, RECIPIENT shall destroy or return immediately all Software and all derivative works.","title":"License"},{"location":"about/license/#license","text":"The legal stuff.","title":"License"},{"location":"about/license/#included-projects","text":"The create-roar-app program was initialized using create-create-app , which is licensed under the MIT License . The developer guide documentation was generated using MkDocs, which is released under the BSD-2-Clause License . Many thanks to the authors and contributors of these wonderful projects.","title":"Included projects"},{"location":"about/license/#roar-licensing","text":"The create-roar-app program, associated documentation, and all ROAR assessments administered by Stanford's Brain Development and Education Lab (BDE Lab) are licensed under the Stanford Academic Software License For ROAR\u2122, the text of which is included below. If you are a member of the BDE Lab and are authoring a new ROAR assessment, you should also adopt the Stanford Academic Software License for ROAR\u2122, which is the default behavior of create-roar-app .","title":"ROAR licensing"},{"location":"about/license/#stanford-academic-software-license-for-roartm","text":"Stanford Docket S21-342: \"Rapid Online Assessment of Reading \"ROAR\u2122\")\" Please address any communications to: jyeatman@stanford.edu and otl@stanford.edu By accessing the software in this folder, you are agreeing to the license terms listed below. THE BOARD OF TRUSTEES OF THE LELAND STANFORD JUNIOR UNIVERSITY (\u201cStanford\u201d) has an assignment to \"Rapid Online Assessment of Reading (\"ROAR\u2122\")\" (\"Software\"), described in Stanford Docket S21-342, which was developed by Professor Jason Yeatman in the Graduate School of Education. By accessing, downloading, accepting, receiving, or using Software, including any accompanying information, materials or manuals you (\"RECIPIENT\") are agreeing to be bound by the terms of this License. If you do not agree to the terms of this License, do not download any files from this directory. STANFORD grants to RECIPIENT a royalty-free, nonexclusive, and nontransferable license to use the Software furnished hereunder, upon the terms and conditions set out below. RECIPIENT acknowledges that the Software is a research tool still in the development stage and that it is being supplied as is, without any accompanying services, support or improvements from STANFORD. STANFORD makes no representations and extends no warranties of any kind, either express or implied other than set out in this License. RECIPIENT agrees to use the Software solely for internal academic, non-commercial purposes and shall not distribute or transfer the Software or any of its derivatives or enhancements from RECIPIENT to another location or to any other person without prior written permission from STANFORD. RECIPIENT agrees not to reverse engineer, reverse assemble, reverse compile decompile, disassemble, or otherwise attempt to re-create the source code for the Software. RECIPIENT acknowledges that any programs created based on the Software will be considered a derivative of Software and owned by STANFORD. RECIPIENT may make modifications to the Software and integrate Software into RECIPIENT's own software. All derivative works and enhancements are owned by Stanford. RECIPIENT may not further distribute Software or its derivatives or enhancements without express written permission of STANFORD. If permission to transfer the Software is given, RECIPIENT warrants that RECIPIENT will not remove or export any part of the Software from the United States except in full compliance with all United States export regulations and other applicable laws. RECIPIENT will use the Software in compliance with all applicable laws, policies and regulations including, but not limited to, any approvals, informed consent and patient confidentiality principles. RECIPIENT will indemnify, hold harmless, and defend STANFORD against any claim of any kind arising out of or related to the exercise of any rights granted under this License or the breach of this License by RECIPIENT. Title and copyright to the Software and any derivatives and any associated documentation shall at all times remain with STANFORD, and RECIPIENT agrees to preserve same. If RECIPIENT plans to publish any peer reviewed papers, abstracts, or similar publications, RECIPIENT agrees to acknowledge Software and its creator, Professor Jason Yeatman, in a manner consistent with academic (industry) practice. If RECIPIENT decides to terminate this License, RECIPIENT shall destroy or return immediately all Software and all derivative works.","title":"STANFORD ACADEMIC SOFTWARE LICENSE FOR ROAR\u2122"},{"location":"common-issues/asset-files/","text":"Advice for asset files \u00b6 Adding asset files to ROAR experiments ROAR experiments can often include a lot of asset files, such as images, audio, and video. But as we include more asset files, our website becomes larger and this can affect application performance. It is therefore important to choose file formats that minimize file size while preserving quality. We recommend the following file formats and conversion tools: Audio files Video files Image files Use the MP3 file format. We recommend using ffmpeg to convert your files to MP3. For example, to convert the file sample.wav to sample.mp3 , use ffmpeg -i sample.wav -codec:a libmp3lame -qscale:a 9 sample.mp3 The -codec:a libmp3lame option tells ffmpeg to use the LAME audio encoder and the -qscale:a 9 option tells ffmpeg to reduce the audio quality in order to reduce file size. In our experience, you can be very aggressive in reducing the audio quality. But if you test out your audio and you aren't happy with the quality, you can always reduce the number that goes after -qscale:a . Use the MP4 file format. We recommend either ffmpeg or Handbrake for converting video files. Here is a nice article on using ffmpeg to convert media files. The specific options that you will need to convert videos depends on the input video format. So we recommend searching the web for best practices in converting your file format. For example, here is an article on converting AVI files to MP4. And here is one with a collection of commands for converting MOV files to MP4. If your image files are of geometric shapes (e.g. logos, icons, etc.), then we recommend using a vector graphic file format such as SVG or PDF. If your image file is a photograph, we recommend using a raster file format like JPEG or PNG. Try to strike a balance between image resolution and file size to save space in your web app.","title":"Advice For Asset Files"},{"location":"common-issues/asset-files/#advice-for-asset-files","text":"Adding asset files to ROAR experiments ROAR experiments can often include a lot of asset files, such as images, audio, and video. But as we include more asset files, our website becomes larger and this can affect application performance. It is therefore important to choose file formats that minimize file size while preserving quality. We recommend the following file formats and conversion tools: Audio files Video files Image files Use the MP3 file format. We recommend using ffmpeg to convert your files to MP3. For example, to convert the file sample.wav to sample.mp3 , use ffmpeg -i sample.wav -codec:a libmp3lame -qscale:a 9 sample.mp3 The -codec:a libmp3lame option tells ffmpeg to use the LAME audio encoder and the -qscale:a 9 option tells ffmpeg to reduce the audio quality in order to reduce file size. In our experience, you can be very aggressive in reducing the audio quality. But if you test out your audio and you aren't happy with the quality, you can always reduce the number that goes after -qscale:a . Use the MP4 file format. We recommend either ffmpeg or Handbrake for converting video files. Here is a nice article on using ffmpeg to convert media files. The specific options that you will need to convert videos depends on the input video format. So we recommend searching the web for best practices in converting your file format. For example, here is an article on converting AVI files to MP4. And here is one with a collection of commands for converting MOV files to MP4. If your image files are of geometric shapes (e.g. logos, icons, etc.), then we recommend using a vector graphic file format such as SVG or PDF. If your image file is a photograph, we recommend using a raster file format like JPEG or PNG. Try to strike a balance between image resolution and file size to save space in your web app.","title":"Advice for asset files"},{"location":"common-issues/audio-stimuli/","text":"Mobile-friendly audio \u00b6 Special instructions for presenting audio stimuli In the previous sections of this guide, we used jsPsych's html-keyboard-response and image-keyboard-response plugins. If you have video stimuli, you could also use the video-keyboard-response plugin . Each of these plugins will work seemlessly on mobile and desktop web browsers. But if you're experiment involves audio stimuli, you will need to do a little bit of hacking to run your app on a mobile browser. In this section, we'll introduce the technique we've used to auto-play audio stimuli on mobile browsers. Expand this to learn about other response modalities All of the plugins listed above end in \"keyboard-response.\" jsPsych also allows other response modalities, like button response: html-button-response , image-button-response , video-button-response swipe response: html-swipe-response , image-swipe-response multi response (a combination of keyboard and button responses): html-multi-response , image-multi-response , video-multi-response And there are many more. Browse the list of official jsPsych plugins and the list of community contributed plugins . What is the problem with audio stimuli on iOS \u00b6 In most cases, playing audio files requires the use of the <audio> HTML tag or the JavaScript Audio() constuctor . jsPsych's audio stimulus plugins use these things under the hood. This works on desktop browsers but we want ROAR apps to be responsive to mobile platforms as well. On iOS platforms, autoplay is disabled. Instead, iOS requires that play be initiated as part of a user interaction (e.g., the user clicks a button). There's a bit of documentation about this on Apple's developer documentation . Practically speaking, this means that jsPsych's audio stimulus plugins, which autoplay audio immediately after a trial is loaded, will not work on iOS. What is the recommended solution \u00b6 We can play audio using Javascript's Audio() constructor if we first ask the participant to click on a button. Moreover, once the participant clicks on a button the first time, we can preserve the original Audio() instance, change its src attribute to any other audio file, and call its play() method without any further user interaction. We'll step through this process below. Hijack the enter-fullscreen button to play audio First we import the necessary files and setup our ROAR timeline as before. Then we import an inoffensive click sound ( click.mp3 ) and create a global audio object (appropriately named globalAudio ) to play this click sound. Lastly we add a fullscreen trial to the timeline and attach an onclick event to the fullscreen button to play the click sound. Here we use an event-related callback function to attach the globalAudio 's play() function to the fullscreen button's click event. // Import jsPsych plugins as before import jsPsychFullScreen from \"@jspsych/plugin-fullscreen\" ; import jsPsychHtmlKeyboardResponse from \"@jspsych/plugin-html-keyboard-response\" ; // Import a click sound import clickSound from '../assets/click.mp3' ; // Import an audio stimulus (we will use this in the next step) import stimulusSound from '../assets/stimulus.mp3' ; // Import the ROAR setup functions as with the examples in the previous section. import { initConfig , initRoarJsPsych , initRoarTimeline , } from './config' ; // Set up the config, jsPsych, and timeline just like before const config = await initConfig (); const jsPsych = initRoarJsPsych ( config ); const timeline = initRoarTimeline ( config ); // Here, create a global Audio object that will \"auto-play\" audio files const globalAudio = new Audio ( clickSound ); // Use the standard enterFullscreen plugin as before const enterFullscreen = { type : jsPsychFullScreen , fullscreen_mode : true , message : `<div><h1>The experiment will switch to full screen mode. <br> Click the button to continue. </h1></div>` , // But now we add an event related callback to play the click audio file once // the user clicks the fullscreen button on_load : () => { const btn = document . getElementById ( 'jspsych-fullscreen-btn' ); btn . onclick = () => { globalAudio . play (); } } }; timeline . push ( enterFullscreen ); Reuse the global audio object when we want to \"auto-play\" audio stimuli Okay, so we have just played an audio file in response to a user interaction, completely in compliance with the iOS developer constraints. In a sense, the user's initial button click on the fullscreen button has \"authorized\" the globalAudio object to play audio. Now we reuse the same globalAudio object to effectively auto-play new stimuli. Here we will use the html-keyboard-response plugin along with another event-related callback function to change the src attribute of the globalAudio object. const audioStimulus = { type : jsPsychHtmlKeyboardResponse , // Once the trial loads, change the audio src to the desired // stimulus and play the sound. on_load : () => { globalAudio . src = stimulusSound , globalAudio . play (); }, stimulus : () => { return `<div> <p>This is the HTML that you would like to show on-screen while the audio stimulus plays. </div>` }, // Arbitrary choices here. Replace with your own values. choices = [ \"a\" , \"b\" , \"c\" ], // Once the trial is finished, we pause the audio so that it doesn't // \"play over\" into the next trail. on_finish : () => { globalAudio . pause (); }, }; timeline . push ( audioStimulus ); Whew! Now we have audio stimuli that \"auto-play\" after a trial finishes loading.","title":"Mobile Friendly Audio Stimuli"},{"location":"common-issues/audio-stimuli/#mobile-friendly-audio","text":"Special instructions for presenting audio stimuli In the previous sections of this guide, we used jsPsych's html-keyboard-response and image-keyboard-response plugins. If you have video stimuli, you could also use the video-keyboard-response plugin . Each of these plugins will work seemlessly on mobile and desktop web browsers. But if you're experiment involves audio stimuli, you will need to do a little bit of hacking to run your app on a mobile browser. In this section, we'll introduce the technique we've used to auto-play audio stimuli on mobile browsers. Expand this to learn about other response modalities All of the plugins listed above end in \"keyboard-response.\" jsPsych also allows other response modalities, like button response: html-button-response , image-button-response , video-button-response swipe response: html-swipe-response , image-swipe-response multi response (a combination of keyboard and button responses): html-multi-response , image-multi-response , video-multi-response And there are many more. Browse the list of official jsPsych plugins and the list of community contributed plugins .","title":"Mobile-friendly audio"},{"location":"common-issues/audio-stimuli/#what-is-the-problem-with-audio-stimuli-on-ios","text":"In most cases, playing audio files requires the use of the <audio> HTML tag or the JavaScript Audio() constuctor . jsPsych's audio stimulus plugins use these things under the hood. This works on desktop browsers but we want ROAR apps to be responsive to mobile platforms as well. On iOS platforms, autoplay is disabled. Instead, iOS requires that play be initiated as part of a user interaction (e.g., the user clicks a button). There's a bit of documentation about this on Apple's developer documentation . Practically speaking, this means that jsPsych's audio stimulus plugins, which autoplay audio immediately after a trial is loaded, will not work on iOS.","title":"What is the problem with audio stimuli on iOS"},{"location":"common-issues/audio-stimuli/#what-is-the-recommended-solution","text":"We can play audio using Javascript's Audio() constructor if we first ask the participant to click on a button. Moreover, once the participant clicks on a button the first time, we can preserve the original Audio() instance, change its src attribute to any other audio file, and call its play() method without any further user interaction. We'll step through this process below. Hijack the enter-fullscreen button to play audio First we import the necessary files and setup our ROAR timeline as before. Then we import an inoffensive click sound ( click.mp3 ) and create a global audio object (appropriately named globalAudio ) to play this click sound. Lastly we add a fullscreen trial to the timeline and attach an onclick event to the fullscreen button to play the click sound. Here we use an event-related callback function to attach the globalAudio 's play() function to the fullscreen button's click event. // Import jsPsych plugins as before import jsPsychFullScreen from \"@jspsych/plugin-fullscreen\" ; import jsPsychHtmlKeyboardResponse from \"@jspsych/plugin-html-keyboard-response\" ; // Import a click sound import clickSound from '../assets/click.mp3' ; // Import an audio stimulus (we will use this in the next step) import stimulusSound from '../assets/stimulus.mp3' ; // Import the ROAR setup functions as with the examples in the previous section. import { initConfig , initRoarJsPsych , initRoarTimeline , } from './config' ; // Set up the config, jsPsych, and timeline just like before const config = await initConfig (); const jsPsych = initRoarJsPsych ( config ); const timeline = initRoarTimeline ( config ); // Here, create a global Audio object that will \"auto-play\" audio files const globalAudio = new Audio ( clickSound ); // Use the standard enterFullscreen plugin as before const enterFullscreen = { type : jsPsychFullScreen , fullscreen_mode : true , message : `<div><h1>The experiment will switch to full screen mode. <br> Click the button to continue. </h1></div>` , // But now we add an event related callback to play the click audio file once // the user clicks the fullscreen button on_load : () => { const btn = document . getElementById ( 'jspsych-fullscreen-btn' ); btn . onclick = () => { globalAudio . play (); } } }; timeline . push ( enterFullscreen ); Reuse the global audio object when we want to \"auto-play\" audio stimuli Okay, so we have just played an audio file in response to a user interaction, completely in compliance with the iOS developer constraints. In a sense, the user's initial button click on the fullscreen button has \"authorized\" the globalAudio object to play audio. Now we reuse the same globalAudio object to effectively auto-play new stimuli. Here we will use the html-keyboard-response plugin along with another event-related callback function to change the src attribute of the globalAudio object. const audioStimulus = { type : jsPsychHtmlKeyboardResponse , // Once the trial loads, change the audio src to the desired // stimulus and play the sound. on_load : () => { globalAudio . src = stimulusSound , globalAudio . play (); }, stimulus : () => { return `<div> <p>This is the HTML that you would like to show on-screen while the audio stimulus plays. </div>` }, // Arbitrary choices here. Replace with your own values. choices = [ \"a\" , \"b\" , \"c\" ], // Once the trial is finished, we pause the audio so that it doesn't // \"play over\" into the next trail. on_finish : () => { globalAudio . pause (); }, }; timeline . push ( audioStimulus ); Whew! Now we have audio stimuli that \"auto-play\" after a trial finishes loading.","title":"What is the recommended solution"},{"location":"developer-guide/","text":"ROAR developer's guide \u00b6 Write your own ROAR assessment The ROAR app development guide provides documentation for developers of ROAR assessments. The guide will take you step-by-step through the process of writing your own ROAR app in which participants will identify images representing hot dogs and \"not hot dogs.\" Please see the Contributing Guide for information on contributing to the create-roar-app initializer or to the developer guide itself. You can jump directly to a page listed below, or use the next and previous buttons in the navigation bar at the top of the page to move through the documentation in order. Prerequisites Installation Folder Structure Configuration Writing Your Experiment Installing Additional Dependencies Styling Deploying Your Experiment Retrieving Data You may also find it helpful to review some ROAR terminology . You can also browse the \"Common Issues\" section in the sidebar to the left to see solutions to common issues that ROAR developers face. This guide uses screencasts Throughout this guide, you will see screencasts like the one below As mentioned in the screencast, you can copy text directly from the screencast. These screencasts are made using asciinema . In the screencasts, you might see us using the micro text editor . We chose that because it's a terminal-based text editor that plays nicely with the screencasting software that we use in this guide. You should use whatever text editor you are already comfortable with. If you don't already have a favorite text editor, we recommend VS Code .","title":"ROAR developer's guide"},{"location":"developer-guide/#roar-developers-guide","text":"Write your own ROAR assessment The ROAR app development guide provides documentation for developers of ROAR assessments. The guide will take you step-by-step through the process of writing your own ROAR app in which participants will identify images representing hot dogs and \"not hot dogs.\" Please see the Contributing Guide for information on contributing to the create-roar-app initializer or to the developer guide itself. You can jump directly to a page listed below, or use the next and previous buttons in the navigation bar at the top of the page to move through the documentation in order. Prerequisites Installation Folder Structure Configuration Writing Your Experiment Installing Additional Dependencies Styling Deploying Your Experiment Retrieving Data You may also find it helpful to review some ROAR terminology . You can also browse the \"Common Issues\" section in the sidebar to the left to see solutions to common issues that ROAR developers face. This guide uses screencasts Throughout this guide, you will see screencasts like the one below As mentioned in the screencast, you can copy text directly from the screencast. These screencasts are made using asciinema . In the screencasts, you might see us using the micro text editor . We chose that because it's a terminal-based text editor that plays nicely with the screencasting software that we use in this guide. You should use whatever text editor you are already comfortable with. If you don't already have a favorite text editor, we recommend VS Code .","title":"ROAR developer's guide"},{"location":"developer-guide/configuration/","text":"Configuration (under the hood) \u00b6 Communicate with the Firestore database and the participant dashboard. ROAR apps work in concert with the participant dashboard and the Firestore database to collect participant information and store trial data, respectively. The details of these interactions have been deliberately abstracted away from you and put \"under the hood\" in src/config.js . In this section, we will explain what you need to do to make your ROAR apps communicate with the dashboard and the database. We will also optionally dive deeper into src/config.js to gain an understanding of how this works. Communicate with the dashboard \u00b6 The participant dashboard provides a unified login experience and helps participants monitor their progress on multiple ROAR assessments. The dashboard keeps track of ROAR apps by assigned each one a unique number called a \"game token\". ROAR apps and the dashboard communicate with each other by passing parameters through the URL's query string . Suppose that your app is hosted at the website https://my-roar-app.web.app. The dashboard can be made to append a \"gameToken\" parameter. For example, https://my-roar-app.web.app?gameToken=1234 for the assessment associated with the game token \"1234\". You might be asking, \"what does my ROAR app do with this information?\" Well, when your assessment is done, it usually redirects the participant back to the dashboard. It has to let the dashboard know somehow that the participant has completed the game. ROAR apps solve this problem using the same query string technology, passing URL parameters for a game token, \"g\", and a completion status, \"c\". For example, redirecting the user to https://reading.stanford.edu/?g=1234&c=1 would communicate to the dashboard that the participant has completed the game with game token 1234. If no game token URL parameter is given to a ROAR app, it's default behavior is to refresh the page after the assessment is done. What you need to do When you register your ROAR app in the participant dashboard, you must append a \"gameToken\" URL parameter. The value of this parameter must match the game token that the dashboard uses for your assessment. Implementation details There are lines of JavaScript code in config.js that inspect the \"gameToken\" parameter of the URL query string and construct the appropriate redirect URL to communicate back with the dashboard. You DO NOT need to edit this code. src/config.js 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 const queryString = new URL ( window . location ). search ; const urlParams = new URLSearchParams ( queryString ); const gameToken = urlParams . get ( 'gameToken' ) || null ; const redirect = () => { if ( gameToken === null ) { // If no game token was passed, we refresh the page rather than // redirecting back to the dashboard window . location . reload (); } else { // Else, redirect back to the dashboard with the game token that // was originally provided window . location . href = `https://reading.stanford.edu/?g= ${ gameToken } &c=1` ; } }; Keep track of changes to your task \u00b6 During the installation phase , you entered some details about your task . We stored this metadata inside of src/config.js and it will be written to the Firestore database whenever a participant takes your assessment. This helps you keep track of which task your participant is taking. Furthermore, your ROAR app also keeps track of variations in your task by assigning a new variant every time you change your source code. What you need to do Nothing! Implementation details There are lines of JavaScript code in config.js that insert your task metadata into an object that is later passed to the Firestore database. src/config.js 11 12 13 14 15 16 17 18 19 20 21 22 23 function configTaskInfo () { const taskInfo = { taskId : 'my-roar-app' , taskName : 'My Roar App' , variantName : 'default' , taskDescription : 'An example ROAR app using the two-alternative forced choice template' , variantDescription : 'default' , // eslint-disable-next-line no-undef srcHash : SRC_HASH , }; return taskInfo ; } That SRC_HASH variable on line 19 contains a hash of your entire src directory. It is calculated in the webpack.config.js file and then inserted into your JavaScript files as a global variable every time you use npm run build or npm start . webpack.config.js 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 module . exports = async ( env , args ) => { const hashOptions = { folders : { exclude : [ '.*' , 'node_modules' , 'test_coverage' ] }, files : { include : [ '*.js' , '*.json' ] }, }; const srcHash = await hashElement ( './src' , hashOptions ); const roarDbDoc = env . dbmode === 'production' ? 'production' : 'development' ; let merged ; switch ( args . mode ) { case 'development' : merged = merge ( commonConfig , developmentConfig ); break ; case 'production' : merged = merge ( commonConfig , productionConfig ); break ; default : throw new Error ( 'No matching configuration was found!' ); } return merge ( merged , { plugins : [ new HtmlWebpackPlugin ({ title : 'My Roar App' }), new webpack . ids . HashedModuleIdsPlugin (), // so that file hashes don't change unexpectedly new webpack . DefinePlugin ({ ROAR_DB_DOC : JSON . stringify ( roarDbDoc ), SRC_HASH : JSON . stringify ( srcHash ), }), ], }, ); }; Connect to the Firestore database \u00b6 ROAR apps store each trial 's data in a Firestore database . In order to communicate with Firebase, your app needs to know certain metadata about your Firebase project. If you are developing an app for the Brain Development and Education Lab (BDELab) , then you don't have to do anything because the correct metadata has already been filled in. If you're developing for another organization, you'll have to supply your Firebase project configuration in the src/firebaseConfig.js file. The BDELab's Firestore database has separate collections for development and production data. So while you are developing your app, any trial data that you produce is kept separate from the experimental data of our in-production apps. Once you are ready to deploy your experiment in production, you're data will be stored in the production part of the database. By default, the development data will be stored in \" dev my-roar-app \", where the last element of that path will depend on the name that you gave to your ROAR app during installation. When deployed, your assessment data will be stored in \" prod roar-prod .\" What you need to do If you are storing your data in your own Firestore database, supply your Firebase project configuration in the src/firebaseConfig.js file. If you are developing for the BDELab, this step isn't necessary. To switch between the production and development portions of the database, use the :prod and :dev versions of the npm run commands. For example, npm run build:dev will build your app in the dist folder and configure it to store data in the development portion of the database. Conversely, npm run build:prod will configure it to write to the production portion of the database. There are similar sub-commands for npm run start . Lastly, if you type npm start or npm run build on their own without specifying :prod or :dev , the default behavior is to write to the development portion of the database. Implementation details The \"scripts\" portion of package.json contains the specialized :prod and :dev commands. Using :prod tells webpack to set the dbmode environment variable to \"production\", while using :dev sets that variable to \"development.\" package.json 7 8 9 10 11 12 13 14 15 \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"build\" : \"npx webpack --mode production\" , \"build:dev\" : \"npm run build -- --env dbmode=development\" , \"build:prod\" : \"npm run build -- --env dbmode=production\" , \"start\" : \"npx webpack serve --open --mode development\" , \"start:dev\" : \"npm run start -- --env dbmode=development\" , \"start:prod\" : \"npm run start -- --env dbmode=production\" }, webpack.config.js 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 module . exports = async ( env , args ) => { const hashOptions = { folders : { exclude : [ '.*' , 'node_modules' , 'test_coverage' ] }, files : { include : [ '*.js' , '*.json' ] }, }; const srcHash = await hashElement ( './src' , hashOptions ); const roarDbDoc = env . dbmode === 'production' ? 'production' : 'development' ; let merged ; switch ( args . mode ) { case 'development' : merged = merge ( commonConfig , developmentConfig ); break ; case 'production' : merged = merge ( commonConfig , productionConfig ); break ; default : throw new Error ( 'No matching configuration was found!' ); } return merge ( merged , { plugins : [ new HtmlWebpackPlugin ({ title : 'My Roar App' }), new webpack . ids . HashedModuleIdsPlugin (), // so that file hashes don't change unexpectedly new webpack . DefinePlugin ({ ROAR_DB_DOC : JSON . stringify ( roarDbDoc ), SRC_HASH : JSON . stringify ( srcHash ), }), ], }, ); }; The ROAR_DB_DOC global variable is then used inside of src/firebaseConfig.js to set the root document in Firestore. src/firebaseConfig.js 3 4 5 6 // eslint-disable-next-line no-undef const prodDoc = 'your-org-name' === 'yeatmanlab' ? [ 'prod' , 'roar-prod' ] : [ 'external' , 'your-org-name' ]; // eslint-disable-next-line no-undef const rootDoc = ROAR_DB_DOC === 'production' ? prodDoc : [ 'dev' , 'my-roar-app' ]; Write trial data \u00b6 Now that the ROAR app is connected to the Firestore database, you're going to want to write some trial data to it. To do so, you MUST append a single save_trial : true field to the data collected by a jsPsych trial . What you need to do You MUST add specific data to any trial you want to save to the Firestore database. Here are instructions on how to add additional data to any jsPsych trial . In our case, we are required to add save_trial : true to the trial data. For example, const trialSavedToFirestore { type : jsPsychHtmlKeyboardResponse , stimulus : \"Press y to save this trial to firestore\" choices : [ 'y' ], // Here is where we specify that we should save the trial to Firestore data : { save_trial : true , }, }, In the template that we are using in this developer's guide, you can see that this is already done in src/index.js on lines 56-61. Implementation details In src/config.js , we added an event-related callback function to every single jsPsych trial . It gets called after the data gets updated and checks to see if the save_trial field is true . If so, it combines the trial data with some predefined timing and user data and writes it to the Firestore database using the roar-firekit library. src/config.js 125 126 127 128 129 130 131 132 133 jsPsych . opts . on_data_update = extend ( jsPsych . opts . on_data_update , ( data ) => { if ( data . save_trial ) { config . firekit ? . writeTrial ({ timingData , userInfo : config . firekit ? . userInfo , ... data , }); } });","title":"Configuration"},{"location":"developer-guide/configuration/#configuration-under-the-hood","text":"Communicate with the Firestore database and the participant dashboard. ROAR apps work in concert with the participant dashboard and the Firestore database to collect participant information and store trial data, respectively. The details of these interactions have been deliberately abstracted away from you and put \"under the hood\" in src/config.js . In this section, we will explain what you need to do to make your ROAR apps communicate with the dashboard and the database. We will also optionally dive deeper into src/config.js to gain an understanding of how this works.","title":"Configuration (under the hood)"},{"location":"developer-guide/configuration/#communicate-with-the-dashboard","text":"The participant dashboard provides a unified login experience and helps participants monitor their progress on multiple ROAR assessments. The dashboard keeps track of ROAR apps by assigned each one a unique number called a \"game token\". ROAR apps and the dashboard communicate with each other by passing parameters through the URL's query string . Suppose that your app is hosted at the website https://my-roar-app.web.app. The dashboard can be made to append a \"gameToken\" parameter. For example, https://my-roar-app.web.app?gameToken=1234 for the assessment associated with the game token \"1234\". You might be asking, \"what does my ROAR app do with this information?\" Well, when your assessment is done, it usually redirects the participant back to the dashboard. It has to let the dashboard know somehow that the participant has completed the game. ROAR apps solve this problem using the same query string technology, passing URL parameters for a game token, \"g\", and a completion status, \"c\". For example, redirecting the user to https://reading.stanford.edu/?g=1234&c=1 would communicate to the dashboard that the participant has completed the game with game token 1234. If no game token URL parameter is given to a ROAR app, it's default behavior is to refresh the page after the assessment is done. What you need to do When you register your ROAR app in the participant dashboard, you must append a \"gameToken\" URL parameter. The value of this parameter must match the game token that the dashboard uses for your assessment. Implementation details There are lines of JavaScript code in config.js that inspect the \"gameToken\" parameter of the URL query string and construct the appropriate redirect URL to communicate back with the dashboard. You DO NOT need to edit this code. src/config.js 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 const queryString = new URL ( window . location ). search ; const urlParams = new URLSearchParams ( queryString ); const gameToken = urlParams . get ( 'gameToken' ) || null ; const redirect = () => { if ( gameToken === null ) { // If no game token was passed, we refresh the page rather than // redirecting back to the dashboard window . location . reload (); } else { // Else, redirect back to the dashboard with the game token that // was originally provided window . location . href = `https://reading.stanford.edu/?g= ${ gameToken } &c=1` ; } };","title":"Communicate with the dashboard"},{"location":"developer-guide/configuration/#keep-track-of-changes-to-your-task","text":"During the installation phase , you entered some details about your task . We stored this metadata inside of src/config.js and it will be written to the Firestore database whenever a participant takes your assessment. This helps you keep track of which task your participant is taking. Furthermore, your ROAR app also keeps track of variations in your task by assigning a new variant every time you change your source code. What you need to do Nothing! Implementation details There are lines of JavaScript code in config.js that insert your task metadata into an object that is later passed to the Firestore database. src/config.js 11 12 13 14 15 16 17 18 19 20 21 22 23 function configTaskInfo () { const taskInfo = { taskId : 'my-roar-app' , taskName : 'My Roar App' , variantName : 'default' , taskDescription : 'An example ROAR app using the two-alternative forced choice template' , variantDescription : 'default' , // eslint-disable-next-line no-undef srcHash : SRC_HASH , }; return taskInfo ; } That SRC_HASH variable on line 19 contains a hash of your entire src directory. It is calculated in the webpack.config.js file and then inserted into your JavaScript files as a global variable every time you use npm run build or npm start . webpack.config.js 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 module . exports = async ( env , args ) => { const hashOptions = { folders : { exclude : [ '.*' , 'node_modules' , 'test_coverage' ] }, files : { include : [ '*.js' , '*.json' ] }, }; const srcHash = await hashElement ( './src' , hashOptions ); const roarDbDoc = env . dbmode === 'production' ? 'production' : 'development' ; let merged ; switch ( args . mode ) { case 'development' : merged = merge ( commonConfig , developmentConfig ); break ; case 'production' : merged = merge ( commonConfig , productionConfig ); break ; default : throw new Error ( 'No matching configuration was found!' ); } return merge ( merged , { plugins : [ new HtmlWebpackPlugin ({ title : 'My Roar App' }), new webpack . ids . HashedModuleIdsPlugin (), // so that file hashes don't change unexpectedly new webpack . DefinePlugin ({ ROAR_DB_DOC : JSON . stringify ( roarDbDoc ), SRC_HASH : JSON . stringify ( srcHash ), }), ], }, ); };","title":"Keep track of changes to your task"},{"location":"developer-guide/configuration/#connect-to-the-firestore-database","text":"ROAR apps store each trial 's data in a Firestore database . In order to communicate with Firebase, your app needs to know certain metadata about your Firebase project. If you are developing an app for the Brain Development and Education Lab (BDELab) , then you don't have to do anything because the correct metadata has already been filled in. If you're developing for another organization, you'll have to supply your Firebase project configuration in the src/firebaseConfig.js file. The BDELab's Firestore database has separate collections for development and production data. So while you are developing your app, any trial data that you produce is kept separate from the experimental data of our in-production apps. Once you are ready to deploy your experiment in production, you're data will be stored in the production part of the database. By default, the development data will be stored in \" dev my-roar-app \", where the last element of that path will depend on the name that you gave to your ROAR app during installation. When deployed, your assessment data will be stored in \" prod roar-prod .\" What you need to do If you are storing your data in your own Firestore database, supply your Firebase project configuration in the src/firebaseConfig.js file. If you are developing for the BDELab, this step isn't necessary. To switch between the production and development portions of the database, use the :prod and :dev versions of the npm run commands. For example, npm run build:dev will build your app in the dist folder and configure it to store data in the development portion of the database. Conversely, npm run build:prod will configure it to write to the production portion of the database. There are similar sub-commands for npm run start . Lastly, if you type npm start or npm run build on their own without specifying :prod or :dev , the default behavior is to write to the development portion of the database. Implementation details The \"scripts\" portion of package.json contains the specialized :prod and :dev commands. Using :prod tells webpack to set the dbmode environment variable to \"production\", while using :dev sets that variable to \"development.\" package.json 7 8 9 10 11 12 13 14 15 \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" , \"build\" : \"npx webpack --mode production\" , \"build:dev\" : \"npm run build -- --env dbmode=development\" , \"build:prod\" : \"npm run build -- --env dbmode=production\" , \"start\" : \"npx webpack serve --open --mode development\" , \"start:dev\" : \"npm run start -- --env dbmode=development\" , \"start:prod\" : \"npm run start -- --env dbmode=production\" }, webpack.config.js 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 module . exports = async ( env , args ) => { const hashOptions = { folders : { exclude : [ '.*' , 'node_modules' , 'test_coverage' ] }, files : { include : [ '*.js' , '*.json' ] }, }; const srcHash = await hashElement ( './src' , hashOptions ); const roarDbDoc = env . dbmode === 'production' ? 'production' : 'development' ; let merged ; switch ( args . mode ) { case 'development' : merged = merge ( commonConfig , developmentConfig ); break ; case 'production' : merged = merge ( commonConfig , productionConfig ); break ; default : throw new Error ( 'No matching configuration was found!' ); } return merge ( merged , { plugins : [ new HtmlWebpackPlugin ({ title : 'My Roar App' }), new webpack . ids . HashedModuleIdsPlugin (), // so that file hashes don't change unexpectedly new webpack . DefinePlugin ({ ROAR_DB_DOC : JSON . stringify ( roarDbDoc ), SRC_HASH : JSON . stringify ( srcHash ), }), ], }, ); }; The ROAR_DB_DOC global variable is then used inside of src/firebaseConfig.js to set the root document in Firestore. src/firebaseConfig.js 3 4 5 6 // eslint-disable-next-line no-undef const prodDoc = 'your-org-name' === 'yeatmanlab' ? [ 'prod' , 'roar-prod' ] : [ 'external' , 'your-org-name' ]; // eslint-disable-next-line no-undef const rootDoc = ROAR_DB_DOC === 'production' ? prodDoc : [ 'dev' , 'my-roar-app' ];","title":"Connect to the Firestore database"},{"location":"developer-guide/configuration/#write-trial-data","text":"Now that the ROAR app is connected to the Firestore database, you're going to want to write some trial data to it. To do so, you MUST append a single save_trial : true field to the data collected by a jsPsych trial . What you need to do You MUST add specific data to any trial you want to save to the Firestore database. Here are instructions on how to add additional data to any jsPsych trial . In our case, we are required to add save_trial : true to the trial data. For example, const trialSavedToFirestore { type : jsPsychHtmlKeyboardResponse , stimulus : \"Press y to save this trial to firestore\" choices : [ 'y' ], // Here is where we specify that we should save the trial to Firestore data : { save_trial : true , }, }, In the template that we are using in this developer's guide, you can see that this is already done in src/index.js on lines 56-61. Implementation details In src/config.js , we added an event-related callback function to every single jsPsych trial . It gets called after the data gets updated and checks to see if the save_trial field is true . If so, it combines the trial data with some predefined timing and user data and writes it to the Firestore database using the roar-firekit library. src/config.js 125 126 127 128 129 130 131 132 133 jsPsych . opts . on_data_update = extend ( jsPsych . opts . on_data_update , ( data ) => { if ( data . save_trial ) { config . firekit ? . writeTrial ({ timingData , userInfo : config . firekit ? . userInfo , ... data , }); } });","title":"Write trial data"},{"location":"developer-guide/deploying-your-experiment/","text":"Deployment \u00b6 Host your experiment on the web Bug You have reached a page that is under construction. Please be patient with us as we update the developer's guide.","title":"Deploying Your Experiment"},{"location":"developer-guide/deploying-your-experiment/#deployment","text":"Host your experiment on the web Bug You have reached a page that is under construction. Please be patient with us as we update the developer's guide.","title":"Deployment"},{"location":"developer-guide/folder-structure/","text":"Folder Structure \u00b6 Getting to know your project directory After creation, your project should look something like this: my-roar-app \u251c\u2500\u2500 .eslintrc.json \u251c\u2500\u2500 .git/ \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 css/ \u2502 \u2502 \u2514\u2500\u2500 roar.css \u2502 \u251c\u2500\u2500 config.js \u2502 \u251c\u2500\u2500 firebaseConfig.js \u2502 \u251c\u2500\u2500 index.js \u2502 \u251c\u2500\u2500 loadAssets.js \u2502 \u2514\u2500\u2500 logger.js \u2514\u2500\u2500 webpack.config.js Folder contents may vary depending on which template you used. Here is a description of the various files in your project: Files you have to edit \u00b6 src/index.js : This file contains your experiments primary source code. See Writing Your Experiment for more details. src/loadAssets.js : This file loads media, such as images, videos, and audio, that is needed for your stimuli. See Writing Your Experiment for further details. Files you probably should edit \u00b6 README.md : This file helps you communicate important information about your project. Read more about it here . Files you may edit but probably won't need to \u00b6 src/config.js : This file contains experiment configuration details and code that helps your experiment communicate with the participant dashboard and the Firestore database. See Configuration for more details. src/firebaseConfig.js : This file contains additional configuration information to help your app communicate with the Firestore database. See Configuration for more details. src/logger.js : The JavaScript code in this file implements a logger to write debugging information to the console. src/css/roar.css : This Cascading Style Sheet file describes how the HTML elements in your web experiement are to be displayed. See the styling section for more information on editing this file. .gitignore : This file tells git which files and directories to ignore when you make commits. Read more in the Git Handbook . You might want to add to this file if you create new files in your applications folder but do not want to commit this to your git repository. .eslintrc.json : Your new ROAR app uses ESLint to make your code more consistent and avoid bugs. This file is an ESLint configuration file that specified some of the options for ESLint. You should not have to edit this file. LICENSE : The LICENSE file for your app. By default, all ROAR apps adopt the Stanford Academic Software License For ROAR\u2122. See the licensing page for more information. package.json : This is npm's configuration file. Read more here . Among other things, it stores metadata about your project. It should be populated based on the answers you provided when creating your ROAR app. Usually, you won't need to edit this file. We recomment that you install dependencies using npm rather than editing this file directly. Files you should not edit \u00b6 .git/ : This folder contains all of the information that is necessary for version control of your project using git. This folders contents are explained in more detail in the git documentation . You do not need to understand, nor should you edit, the .git folder to create your ROAR app. node_modules : Think of this as a cache for the external JavaScript modules/libraries that your ROAR app depends on. Do not edit this folder. package-lock.json : This file specifies the exact dependency tree for your application. Find out more here . Do not edit this file . webpack.config.js : Webpack is a \"module bundler.\" It takes your source code files and transforms them for deployment and usage in a web browser. The webpack.config.js file configures how webpack bundles your files. You do not need to understand how these files work in order to build your ROAR application. Adding and removing files \u00b6 For the project to build, you must have an index.js file in your src directory . If you know what you're doing, you can delete or rename the other files in src . You may create subdirectories inside src . For faster rebuilds, only files inside src are processed by webpack. You need to put any JS and CSS files inside src , otherwise webpack won\u2019t see them. You can create more top-level directories. They will not be included in the production build so you can use them for things like documentation or creation of custom stimuli.","title":"Folder Structure"},{"location":"developer-guide/folder-structure/#folder-structure","text":"Getting to know your project directory After creation, your project should look something like this: my-roar-app \u251c\u2500\u2500 .eslintrc.json \u251c\u2500\u2500 .git/ \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 LICENSE \u251c\u2500\u2500 README.md \u251c\u2500\u2500 node_modules \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 css/ \u2502 \u2502 \u2514\u2500\u2500 roar.css \u2502 \u251c\u2500\u2500 config.js \u2502 \u251c\u2500\u2500 firebaseConfig.js \u2502 \u251c\u2500\u2500 index.js \u2502 \u251c\u2500\u2500 loadAssets.js \u2502 \u2514\u2500\u2500 logger.js \u2514\u2500\u2500 webpack.config.js Folder contents may vary depending on which template you used. Here is a description of the various files in your project:","title":"Folder Structure"},{"location":"developer-guide/folder-structure/#files-you-have-to-edit","text":"src/index.js : This file contains your experiments primary source code. See Writing Your Experiment for more details. src/loadAssets.js : This file loads media, such as images, videos, and audio, that is needed for your stimuli. See Writing Your Experiment for further details.","title":"Files you have to edit"},{"location":"developer-guide/folder-structure/#files-you-probably-should-edit","text":"README.md : This file helps you communicate important information about your project. Read more about it here .","title":"Files you probably should edit"},{"location":"developer-guide/folder-structure/#files-you-may-edit-but-probably-wont-need-to","text":"src/config.js : This file contains experiment configuration details and code that helps your experiment communicate with the participant dashboard and the Firestore database. See Configuration for more details. src/firebaseConfig.js : This file contains additional configuration information to help your app communicate with the Firestore database. See Configuration for more details. src/logger.js : The JavaScript code in this file implements a logger to write debugging information to the console. src/css/roar.css : This Cascading Style Sheet file describes how the HTML elements in your web experiement are to be displayed. See the styling section for more information on editing this file. .gitignore : This file tells git which files and directories to ignore when you make commits. Read more in the Git Handbook . You might want to add to this file if you create new files in your applications folder but do not want to commit this to your git repository. .eslintrc.json : Your new ROAR app uses ESLint to make your code more consistent and avoid bugs. This file is an ESLint configuration file that specified some of the options for ESLint. You should not have to edit this file. LICENSE : The LICENSE file for your app. By default, all ROAR apps adopt the Stanford Academic Software License For ROAR\u2122. See the licensing page for more information. package.json : This is npm's configuration file. Read more here . Among other things, it stores metadata about your project. It should be populated based on the answers you provided when creating your ROAR app. Usually, you won't need to edit this file. We recomment that you install dependencies using npm rather than editing this file directly.","title":" Files you may edit but probably won't need to"},{"location":"developer-guide/folder-structure/#files-you-should-not-edit","text":".git/ : This folder contains all of the information that is necessary for version control of your project using git. This folders contents are explained in more detail in the git documentation . You do not need to understand, nor should you edit, the .git folder to create your ROAR app. node_modules : Think of this as a cache for the external JavaScript modules/libraries that your ROAR app depends on. Do not edit this folder. package-lock.json : This file specifies the exact dependency tree for your application. Find out more here . Do not edit this file . webpack.config.js : Webpack is a \"module bundler.\" It takes your source code files and transforms them for deployment and usage in a web browser. The webpack.config.js file configures how webpack bundles your files. You do not need to understand how these files work in order to build your ROAR application.","title":"Files you should not edit"},{"location":"developer-guide/folder-structure/#adding-and-removing-files","text":"For the project to build, you must have an index.js file in your src directory . If you know what you're doing, you can delete or rename the other files in src . You may create subdirectories inside src . For faster rebuilds, only files inside src are processed by webpack. You need to put any JS and CSS files inside src , otherwise webpack won\u2019t see them. You can create more top-level directories. They will not be included in the production build so you can use them for things like documentation or creation of custom stimuli.","title":"Adding and removing files"},{"location":"developer-guide/installation/","text":"ROAR App Installation \u00b6 Use the create-roar-app template to create your app Installation \u00b6 To create a new app, first navigate to the directory in which you want to store all of your ROAR assessments. For example mkdir -p ~/roar-apps cd ~/roar-apps You may then choose one of the following methods: Installation options npx (recommended) npm yarn npx create-roar-app@latest my-roar-app npx is a package runner tool that comes with npm 5.2+ and higher. npm init roar-app@latest my-roar-app npm init <initializer> is available in npm 6+ yarn create roar-app@latest my-roar-app yarn create <starter-kit-package> is available in Yarn 0.25+ Follow the on-screen prompts and answer questions about your application. Here's an example: This will create a directory called my-roar-app inside the current folder. Inside that directory, it will generate the initial project structure and install some dependencies. Once the installation is done, you can navigate to your project folder: cd my-roar-app and make edits to your experiment's code. See the following pages for more detail: Configuration Writing Your Experiment Styling Available commands \u00b6 Inside the newly created project, you can run some built-in commands: See a list of available commands npm yarn npm run yarn run Start a development server npm yarn npm start yarn start Runs the app in development mode. Visit http://localhost:8080 to view it in the browser. The page will automatically reload if you make changes to the code. We recommend using the Google Chrome browser for your web development. Use the Chrome DevTools to view your web application's DOM or debug your JavaScript . To stop the development server in your console, press Ctrl + C . Build your app for deployment npm yarn npm run build yarn build Builds the app for production to the dist folder. This correctly bundles your ROAR app in production mode and optimizes the build for the best performance. Your app is then ready to be deployed . There are other commands as well. The difference between npm run build:dev and npm run build:prod , for example, is explained in the Configuration section . Make your first commit \u00b6 Before we start configuring your app, let's commit the files that the create-roar-app initializer created in your app directory. screencast code only git add . git commit -m \"First commit. Add files created by the create-roar-app initializer\" Now that you've committed the initial files, let's explore the folder we've created and start writing your experiment.","title":"Installation"},{"location":"developer-guide/installation/#roar-app-installation","text":"Use the create-roar-app template to create your app","title":"ROAR App Installation"},{"location":"developer-guide/installation/#installation","text":"To create a new app, first navigate to the directory in which you want to store all of your ROAR assessments. For example mkdir -p ~/roar-apps cd ~/roar-apps You may then choose one of the following methods: Installation options npx (recommended) npm yarn npx create-roar-app@latest my-roar-app npx is a package runner tool that comes with npm 5.2+ and higher. npm init roar-app@latest my-roar-app npm init <initializer> is available in npm 6+ yarn create roar-app@latest my-roar-app yarn create <starter-kit-package> is available in Yarn 0.25+ Follow the on-screen prompts and answer questions about your application. Here's an example: This will create a directory called my-roar-app inside the current folder. Inside that directory, it will generate the initial project structure and install some dependencies. Once the installation is done, you can navigate to your project folder: cd my-roar-app and make edits to your experiment's code. See the following pages for more detail: Configuration Writing Your Experiment Styling","title":"Installation"},{"location":"developer-guide/installation/#available-commands","text":"Inside the newly created project, you can run some built-in commands: See a list of available commands npm yarn npm run yarn run Start a development server npm yarn npm start yarn start Runs the app in development mode. Visit http://localhost:8080 to view it in the browser. The page will automatically reload if you make changes to the code. We recommend using the Google Chrome browser for your web development. Use the Chrome DevTools to view your web application's DOM or debug your JavaScript . To stop the development server in your console, press Ctrl + C . Build your app for deployment npm yarn npm run build yarn build Builds the app for production to the dist folder. This correctly bundles your ROAR app in production mode and optimizes the build for the best performance. Your app is then ready to be deployed . There are other commands as well. The difference between npm run build:dev and npm run build:prod , for example, is explained in the Configuration section .","title":"Available commands"},{"location":"developer-guide/installation/#make-your-first-commit","text":"Before we start configuring your app, let's commit the files that the create-roar-app initializer created in your app directory. screencast code only git add . git commit -m \"First commit. Add files created by the create-roar-app initializer\" Now that you've committed the initial files, let's explore the folder we've created and start writing your experiment.","title":"Make your first commit"},{"location":"developer-guide/installing-dependencies/","text":"Installing additional dependencies \u00b6 Use external libraries to add functionality to your experiment As you develop your ROAR app, you may discover that you need to incorporate additional functionality using external JavaScript libraries. To do so, you'll follow outline of this section: installing the new library, importing it at the top of some JavaScript file, and using it in your source code. As a pedagogical example, in this section, we will install, import, and use the image-keyboard-response plugin. In the writing your experiment section , you added a block to your experiment asking participants to differentiate between cat and dog images. You may have noticed that we created the block2Targets array in src/loadAssets.js in order to pass an HTML string as a stimulus to the jsPsychHtmlKeyboardResponse plugin. But jsPsych already has its own jsPsychImageKeyboardResponse plugin that takes an image stimulus as input and obviates the need for creating the block2Targets array. In this section, we will install the jsPsychImageKeyboardResponse plugin and adapt your experiment to use it. Before we start, be sure to commit your work so far into version control. Installing the new library \u00b6 First, use either npm or yarn to install the new plugin code only screencast Use either npm or yarn to install the new package npm (recommended) yarn npm install @jspsych/plugin-image-keyboard-response yarn install @jspsych/plugin-image-button-response You can then verify that @jspsych/plugin-image-keyboard-response has added to the dependencies section of the package.json file. Importing and using the new library \u00b6 Now we are ready to start using the new plugin. code only screencast First, remove the HTML image tag from the allTargets and block2Targets arrays in src/loadAssets.js : src/loadAssets.js 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const allFiles = hotDogFiles . concat ( notHotDogFiles ); export const allTargets = allFiles . map (( url ) => ({ target : url , isHotDog : ! url . includes ( 'nothotdog' ), })); /* preload images */ export const preloadImages = { type : jsPsychPreload , images : allFiles , }; const block2Files = catImages . concat ( dogFiles ); export const block2Targets = block2Files . map (( url ) => ({ target : url , isDog : url . includes ( 'dog' ), })); Next, change import the new plugin type in src/index.js : src/index.js 1 2 3 4 // jsPsych imports import jsPsychFullScreen from '@jspsych/plugin-fullscreen' ; import jsPsychHtmlKeyboardResponse from '@jspsych/plugin-html-keyboard-response' ; import jsPsychImageKeyboardResponse from '@jspsych/plugin-image-keyboard-response' ; Later on, use this new plugin type in the hotDogTrials objects. src/index.js 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 const hotDogTrials = { timeline : [ { type : jsPsychHtmlKeyboardResponse , stimulus : '<div style=\"font-size:60px;\">+</div>' , choices : 'NO_KEYS' , trial_duration : 500 , }, { // Here we change the plugin type type : jsPsychImageKeyboardResponse , stimulus : jsPsych . timelineVariable ( 'target' ), choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a hot dog?</p> <p>If yes, press the right arrow key.</p> <p>If no, press the left arrow key.</p> ` , // And here we specify the stimulus height and width, // which we previously did in the `allTargets` array. stimulus_height : 250 , stimulus_width : 250 , data : { // Here is where we specify that we should save the trial to Firestore save_trial : true , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. }, }, ], timeline_variables : allTargets , sample : { type : 'without-replacement' , size : 10 , }, }; And likewise for the catDogTrials object: src/index.js 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 const catDogTrials = { timeline : [ { type : jsPsychImageKeyboardResponse , stimulus : '<div style=\"font-size:60px;\">+</div>' , choices : 'NO_KEYS' , trial_duration : 500 , }, { type : jsPsychHtmlKeyboardResponse , stimulus : jsPsych . timelineVariable ( 'target' ), choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a dog?</p> <p>If yes, press the right arrow key.</p> <p>If no, press the left arrow key.</p> ` , stimulus_height : 250 , stimulus_width : 250 , data : { // Here is where we specify that we should save the trial to Firestore save_trial : true , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. }, }, ], timeline_variables : block2Targets , sample : { type : 'without-replacement' , size : 10 , }, }; Congratulations! You just used your first new plugin type!","title":"Installing Additional Dependencies"},{"location":"developer-guide/installing-dependencies/#installing-additional-dependencies","text":"Use external libraries to add functionality to your experiment As you develop your ROAR app, you may discover that you need to incorporate additional functionality using external JavaScript libraries. To do so, you'll follow outline of this section: installing the new library, importing it at the top of some JavaScript file, and using it in your source code. As a pedagogical example, in this section, we will install, import, and use the image-keyboard-response plugin. In the writing your experiment section , you added a block to your experiment asking participants to differentiate between cat and dog images. You may have noticed that we created the block2Targets array in src/loadAssets.js in order to pass an HTML string as a stimulus to the jsPsychHtmlKeyboardResponse plugin. But jsPsych already has its own jsPsychImageKeyboardResponse plugin that takes an image stimulus as input and obviates the need for creating the block2Targets array. In this section, we will install the jsPsychImageKeyboardResponse plugin and adapt your experiment to use it. Before we start, be sure to commit your work so far into version control.","title":"Installing additional dependencies"},{"location":"developer-guide/installing-dependencies/#installing-the-new-library","text":"First, use either npm or yarn to install the new plugin code only screencast Use either npm or yarn to install the new package npm (recommended) yarn npm install @jspsych/plugin-image-keyboard-response yarn install @jspsych/plugin-image-button-response You can then verify that @jspsych/plugin-image-keyboard-response has added to the dependencies section of the package.json file.","title":"Installing the new library"},{"location":"developer-guide/installing-dependencies/#importing-and-using-the-new-library","text":"Now we are ready to start using the new plugin. code only screencast First, remove the HTML image tag from the allTargets and block2Targets arrays in src/loadAssets.js : src/loadAssets.js 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const allFiles = hotDogFiles . concat ( notHotDogFiles ); export const allTargets = allFiles . map (( url ) => ({ target : url , isHotDog : ! url . includes ( 'nothotdog' ), })); /* preload images */ export const preloadImages = { type : jsPsychPreload , images : allFiles , }; const block2Files = catImages . concat ( dogFiles ); export const block2Targets = block2Files . map (( url ) => ({ target : url , isDog : url . includes ( 'dog' ), })); Next, change import the new plugin type in src/index.js : src/index.js 1 2 3 4 // jsPsych imports import jsPsychFullScreen from '@jspsych/plugin-fullscreen' ; import jsPsychHtmlKeyboardResponse from '@jspsych/plugin-html-keyboard-response' ; import jsPsychImageKeyboardResponse from '@jspsych/plugin-image-keyboard-response' ; Later on, use this new plugin type in the hotDogTrials objects. src/index.js 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 const hotDogTrials = { timeline : [ { type : jsPsychHtmlKeyboardResponse , stimulus : '<div style=\"font-size:60px;\">+</div>' , choices : 'NO_KEYS' , trial_duration : 500 , }, { // Here we change the plugin type type : jsPsychImageKeyboardResponse , stimulus : jsPsych . timelineVariable ( 'target' ), choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a hot dog?</p> <p>If yes, press the right arrow key.</p> <p>If no, press the left arrow key.</p> ` , // And here we specify the stimulus height and width, // which we previously did in the `allTargets` array. stimulus_height : 250 , stimulus_width : 250 , data : { // Here is where we specify that we should save the trial to Firestore save_trial : true , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. }, }, ], timeline_variables : allTargets , sample : { type : 'without-replacement' , size : 10 , }, }; And likewise for the catDogTrials object: src/index.js 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 const catDogTrials = { timeline : [ { type : jsPsychImageKeyboardResponse , stimulus : '<div style=\"font-size:60px;\">+</div>' , choices : 'NO_KEYS' , trial_duration : 500 , }, { type : jsPsychHtmlKeyboardResponse , stimulus : jsPsych . timelineVariable ( 'target' ), choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a dog?</p> <p>If yes, press the right arrow key.</p> <p>If no, press the left arrow key.</p> ` , stimulus_height : 250 , stimulus_width : 250 , data : { // Here is where we specify that we should save the trial to Firestore save_trial : true , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. }, }, ], timeline_variables : block2Targets , sample : { type : 'without-replacement' , size : 10 , }, }; Congratulations! You just used your first new plugin type!","title":"Importing and using the new library"},{"location":"developer-guide/prerequisites/","text":"ROAR development prerequisites \u00b6 What do you need to get started? Prerequisite knowledge \u00b6 Before you start developing ROAR apps, it is helpful to have some knowledge of the topics listed below. Don't be intimidated if you're not familiar with some things. Imposter's Syndrome Disclaimer There may be a little voice inside your head that is telling you that you're not ready to develop a ROAR application; that your skills aren't nearly good enough to contribute. What could you possibly offer a project like this one? We assure you - the little voice in your head is wrong. If you can write at all, you can write a ROAR app. Creating your first web assessment is a fantastic way to advance one's coding skills. Writing perfect code isn't the measure of a good developer (that would disqualify all of us!); it's trying to create something, making mistakes, and learning from those mistakes. That's how we all improve, and we are happy to help others learn. Here's what you need to know: Familiarity with Javascript We will be developing your web assessment in JavaScript, a programming language that is one of the core technologies of the web. Web development with JavaScript can be efficient and fun! But teaching you JavaScript is beyond the scope of this guide. Instead, we recommend some the following resources: The Modern JavaScript Tutorial W3Schools JavaScript Tutorial MDN Web Docs for JavaScript JavaScript for Data Science Familiarity with jsPsych ROAR apps use jsPsych to create browser-based cognitive and behavioral assessments. jsPsych has some nice documentation to help you get started. From jsPsych's own documentation The page on timelines is a good place to start learning about jsPsych. From there, you might want to complete the hello world tutorial to learn how to set up a jsPsych experiment and the reaction time experiment tutorial to learn the core features of the framework. Familiarity with the command shell You will use the command shell to initialize your app and start your development server. We may use the words \"shell\", \"console\", \"bash\", or \"command prompt\" interchangeably. If you are new to the shell, we recommend the Software Carpentry introduction to the Unix shell . Some knowledge of git and GitHub git is a really useful tool for version control. GitHub sits on top of git and supports collaborative and distributed working. If you're not yet familiar with git, there are lots of great resources to help you git started! Some of our favorites include the git Handbook and the Software Carpentry introduction to git . Software Prerequisites \u00b6 In addition to the prerequisite knowledge above, you will need some software: A command shell A shell is a program where users can type commands. The terms \"shell,\" \"command shell\", and \"terminal\" are used interchangeably throughout this guide. If you don't already have a command shell installed, you can follow these helpful instructions from The Carpentries to install the Bash shell. If you're not sure how to open a terminal on your operating system, see these instructions , also courtesy of The Carpentries . A text editor When you're writing code, it's nice to have a text editor that is optimized for writing code, with features like automatic color-coding of key words. The text editor that we recommend for ROAR development is VS Code . For JavaScript development, you might also want to install these extensions JavaScript (ES6) code snippets ESLint Prettier Quokka.js The default text editor on macOS and Linux is usually set to Vim, which is not famous for being intuitive. If you accidentally find yourself stuck in it, hit the Esc key, followed by : + Q + ! (colon, lower-case 'q', exclamation mark), then hitting Enter to return to the shell. node.js The ROAR development kit requires Node.js, a JavaScript runtime environment. Download and install Node.js here . You\u2019ll need to have Node 14.0.0 or later version on your local development machine. We recommend using the latest LTS version. You can use nvm (macOS/Linux) or nvm-windows to switch Node versions between different projects. git and a GitHub account Follow the Software Carpentry instructions for downloading Git . You will also need an account at github.com . Basic GitHub accounts are free.","title":"Prerequisites"},{"location":"developer-guide/prerequisites/#roar-development-prerequisites","text":"What do you need to get started?","title":"ROAR development prerequisites"},{"location":"developer-guide/prerequisites/#prerequisite-knowledge","text":"Before you start developing ROAR apps, it is helpful to have some knowledge of the topics listed below. Don't be intimidated if you're not familiar with some things. Imposter's Syndrome Disclaimer There may be a little voice inside your head that is telling you that you're not ready to develop a ROAR application; that your skills aren't nearly good enough to contribute. What could you possibly offer a project like this one? We assure you - the little voice in your head is wrong. If you can write at all, you can write a ROAR app. Creating your first web assessment is a fantastic way to advance one's coding skills. Writing perfect code isn't the measure of a good developer (that would disqualify all of us!); it's trying to create something, making mistakes, and learning from those mistakes. That's how we all improve, and we are happy to help others learn. Here's what you need to know: Familiarity with Javascript We will be developing your web assessment in JavaScript, a programming language that is one of the core technologies of the web. Web development with JavaScript can be efficient and fun! But teaching you JavaScript is beyond the scope of this guide. Instead, we recommend some the following resources: The Modern JavaScript Tutorial W3Schools JavaScript Tutorial MDN Web Docs for JavaScript JavaScript for Data Science Familiarity with jsPsych ROAR apps use jsPsych to create browser-based cognitive and behavioral assessments. jsPsych has some nice documentation to help you get started. From jsPsych's own documentation The page on timelines is a good place to start learning about jsPsych. From there, you might want to complete the hello world tutorial to learn how to set up a jsPsych experiment and the reaction time experiment tutorial to learn the core features of the framework. Familiarity with the command shell You will use the command shell to initialize your app and start your development server. We may use the words \"shell\", \"console\", \"bash\", or \"command prompt\" interchangeably. If you are new to the shell, we recommend the Software Carpentry introduction to the Unix shell . Some knowledge of git and GitHub git is a really useful tool for version control. GitHub sits on top of git and supports collaborative and distributed working. If you're not yet familiar with git, there are lots of great resources to help you git started! Some of our favorites include the git Handbook and the Software Carpentry introduction to git .","title":"Prerequisite knowledge"},{"location":"developer-guide/prerequisites/#software-prerequisites","text":"In addition to the prerequisite knowledge above, you will need some software: A command shell A shell is a program where users can type commands. The terms \"shell,\" \"command shell\", and \"terminal\" are used interchangeably throughout this guide. If you don't already have a command shell installed, you can follow these helpful instructions from The Carpentries to install the Bash shell. If you're not sure how to open a terminal on your operating system, see these instructions , also courtesy of The Carpentries . A text editor When you're writing code, it's nice to have a text editor that is optimized for writing code, with features like automatic color-coding of key words. The text editor that we recommend for ROAR development is VS Code . For JavaScript development, you might also want to install these extensions JavaScript (ES6) code snippets ESLint Prettier Quokka.js The default text editor on macOS and Linux is usually set to Vim, which is not famous for being intuitive. If you accidentally find yourself stuck in it, hit the Esc key, followed by : + Q + ! (colon, lower-case 'q', exclamation mark), then hitting Enter to return to the shell. node.js The ROAR development kit requires Node.js, a JavaScript runtime environment. Download and install Node.js here . You\u2019ll need to have Node 14.0.0 or later version on your local development machine. We recommend using the latest LTS version. You can use nvm (macOS/Linux) or nvm-windows to switch Node versions between different projects. git and a GitHub account Follow the Software Carpentry instructions for downloading Git . You will also need an account at github.com . Basic GitHub accounts are free.","title":"Software Prerequisites"},{"location":"developer-guide/retrieving-data/","text":"Retrieving assessment data \u00b6 How to query and retrieve experiment data Once you have deployed your experiment, you will want to retrieve its data to assess it's performance in evaluating your participants' abilities. You can view assessment data one trial at a time by browsing the Firestore database in your web browser or you can bulk download trial information using the roarquery tool . Browsing ROAR data online \u00b6 You can browse your Firestore database's data online by navigating to the Cloud Firestore Data tab in your browser. From there, you can view, and query data. See this guide for more details on how to do that. Retrieving ROAR data from the command line \u00b6 The Firestore Data console is convenient for viewing a small number of database records at a time. But when you want to view or download many data records at a time, it is often easier to use a command line tool. For this reason, we created the roarquery command line tool . See the installation and authentication sections of the roarquery documentation to setup your roarquery tool. Then see the usage page to learn how to use roarquery to filter and retrieve a large number of ROAR trials.","title":"Retrieving Data"},{"location":"developer-guide/retrieving-data/#retrieving-assessment-data","text":"How to query and retrieve experiment data Once you have deployed your experiment, you will want to retrieve its data to assess it's performance in evaluating your participants' abilities. You can view assessment data one trial at a time by browsing the Firestore database in your web browser or you can bulk download trial information using the roarquery tool .","title":"Retrieving assessment data"},{"location":"developer-guide/retrieving-data/#browsing-roar-data-online","text":"You can browse your Firestore database's data online by navigating to the Cloud Firestore Data tab in your browser. From there, you can view, and query data. See this guide for more details on how to do that.","title":"Browsing ROAR data online"},{"location":"developer-guide/retrieving-data/#retrieving-roar-data-from-the-command-line","text":"The Firestore Data console is convenient for viewing a small number of database records at a time. But when you want to view or download many data records at a time, it is often easier to use a command line tool. For this reason, we created the roarquery command line tool . See the installation and authentication sections of the roarquery documentation to setup your roarquery tool. Then see the usage page to learn how to use roarquery to filter and retrieve a large number of ROAR trials.","title":"Retrieving ROAR data from the command line"},{"location":"developer-guide/styling/","text":"Styling \u00b6 Customizing the appearance of your experiment Bug You have reached a page that is under construction. Please be patient with us as we update the developer's guide.","title":"Styling"},{"location":"developer-guide/styling/#styling","text":"Customizing the appearance of your experiment Bug You have reached a page that is under construction. Please be patient with us as we update the developer's guide.","title":"Styling"},{"location":"developer-guide/writing-your-experiment/","text":"Writing your experiment \u00b6 Finally, let's stimulate our participant! Starting the development server \u00b6 Your ROAR app is ready to go out of the box. Let's start the development server to see what the experiment looks like in the browser. code only screencast npm start This will automatically open a new browser tab with your experiment. It should look something like the experiment hosted here : However, you're experiment will automatically update when you make changes to your source code. Adding another block of stimuli \u00b6 Let's pretend that we want to add a new block to our experiment where we ask the participant to further differentiate between cats and dogs. Let's implement that structure now by first adding images of cats and dogs and then editing the experiment's source code to include those new images. Adding more images \u00b6 The first step in creating our new block is hosting the images of dogs and cats that we will use as stimuli. Download these images to your computer cat.zip dog.zip We will demonstrate two different ways to host images: we'll host the cat images along side your experiment and the dog images in a public google cloud storage bucket. Hosting images alongside your experiment \u00b6 code only screencast First download the cat images zip file . Assuming that this file was downloaded to ~/Downloads , do # Make a folder for the cat images mkdir -p src/assets # Navigate to that folder cd src/assets # Move the downloaded zip file to this folder mv ~/Downloads/cat.zip . # Unzip the file unzip cat.zip # And delete the zip file rm cat.zip cd ../.. Now edit the src/loadAssets.js file to load these new cat images. You can add individual files simply by importing them as variables and then referencing them in your code. For example src/loadAssets.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import jsPsychPreload from '@jspsych/plugin-preload' ; import cat1 from './assets/cat/1.jpg' ; import cat2 from './assets/cat/2.jpg' ; import cat3 from './assets/cat/3.jpg' ; import cat4 from './assets/cat/4.jpg' ; import cat5 from './assets/cat/5.jpg' ; // Reference these files in a new array const catImages = [ cat1 , cat2 , cat3 , cat4 , cat5 ]; // Create arrays of hot dog / not hot dog images const numFiles = 5 ; const hotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/hotdog/ ${ idx } .jpg` , ); const notHotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/nothotdog/ ${ idx } .jpg` , ); const allFiles = hotDogFiles . concat ( notHotDogFiles ); export const allTargets = allFiles . map (( url ) => ({ target : `<img src=\" ${ url } \" width=250 height=250>` , isHotDog : ! url . includes ( 'nothotdog' ), })); /* preload images */ export const preloadImages = { type : jsPsychPreload , images : allFiles , }; // Preload the cat image export const preloadCatImages = { type : jsPsychPreload , images : catImages , } And don't forget to commit your changes into git. git add src/assets/cat git add -u git commit -m \"Add cat images for block 2\" Hosting images using a cloud storage provider \u00b6 The above method of hosting image assets alongside your experiment is fine if you only have a few files. But it can become cumbersome to import each file separately if you have a lot of assets. Rather than hosting your files with your website, you can upload them to a cloud storage provider and access your files using a URL. To demonstrate, we have already uploaded the dog images to a Google Cloud Storage bucket. In fact, it is the same bucket that already hosts the hot dog vs. not hot dog images. You can see the images here ( 1 , 2 , 3 , 4 , 5 ). Two popular cloud storage service providers are Google Cloud Storage (GCS) and Amazon Simple Storage Service (S3). To upload your own images and make them publicly available, follow these instructions: Create a storage bucket ( GCS instructions , S3 instructions ) Upload objects to the bucket ( GCS instructions , S3 instructions ) Make the data public ( GCS instructions , S3 instructions ) Then we can add references to the dog image URLs like so code only screencast Edit the src/loadAssets.js file to include the dog image URLs src/loadAssets.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import jsPsychPreload from '@jspsych/plugin-preload' ; import cat1 from './assets/cat/1.jpg' ; import cat2 from './assets/cat/2.jpg' ; import cat3 from './assets/cat/3.jpg' ; import cat4 from './assets/cat/4.jpg' ; import cat5 from './assets/cat/5.jpg' ; // Reference these files in a new array const catImages = [ cat1 , cat2 , cat3 , cat4 , cat5 ]; // Create arrays of hot dog / not hot dog images const numFiles = 5 ; const hotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/hotdog/ ${ idx } .jpg` , ); const notHotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/nothotdog/ ${ idx } .jpg` , ); const dogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/dog/ ${ idx } .jpg` , ); const allFiles = hotDogFiles . concat ( notHotDogFiles ); export const allTargets = allFiles . map (( url ) => ({ target : `<img src=\" ${ url } \" width=250 height=250>` , isHotDog : ! url . includes ( 'nothotdog' ), })); /* preload images */ export const preloadImages = { type : jsPsychPreload , images : allFiles , }; const block2Files = catImages . concat ( dogFiles ); export const block2Targets = block2Files . map (( url ) => ({ target : `<img src=\" ${ url } \" width=250 height=250>` , isDog : url . includes ( 'dog' ), })); // Preload the cat/dog images export const preloadBlock2Images = { type : jsPsychPreload , images : block2Files , }; Making sense of the above javascript If the above line of javascript for dogFiles doesn't make sense to you, let's break it down into its components: Array ( numFiles ) // Yields [ <5 empty items> ] since numFiles = 5 Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ) // Yields [ 1, 2, 3, 4, 5 ] // And Finally Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/dog/ ${ idx } .jpg` , ); // Yields // [ // 'https://storage.googleapis.com/roar-hot-dog-images/dog/1.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/2.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/3.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/4.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/5.jpg' // ] By using the map method , we were able to write the URL pattern just once, following the DRY principle . We use the map method again to convert the raw URLs in the dogImages array to HTML image tags in the block2Targets array. Adding a block of stimuli to index.js \u00b6 Now that we have established references to our new cat vs. dog images, let's create the new block of stimuli. We'll introduce this first by adding only one single stimulus. and then we'll use the same code to add an entire block of stimuli using jsPsych's timeline variables. Adding a single stimulus \u00b6 We will add the first stimulus in the block2Targets array. code only screencast Edit the src/index.js file to include a new instruction set and the new stimuli. At the top of the file, add the following imports src/index.js 11 12 13 14 // Local modules import { initConfig , initRoarJsPsych , initRoarTimeline } from './config' ; import { allTargets , preloadImages , block2Targets , preloadBlock2Images } from './loadAssets' ; Then, a little bit later in the file, add src/index.js 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 timeline . push ( hotDogTrials ); const block2Instructions = { type : jsPsychHtmlKeyboardResponse , stimulus : ` <h3>Great Job!</h3> <p> Now press the right arrow key if the displayed image is of a dog. Press the left arrow key if the displayed image is of a cat. </p> <p>Press any key to continue.</p> ` , }; timeline . push ( preloadBlock2Images ); timeline . push ( block2Instructions ); const catDogTrials = { timeline : [ { type : jsPsychHtmlKeyboardResponse , stimulus : `<div style=\"font-size: 60px;\">+</div>` , choices : 'NO_KEYS' , trial_duration : 500 , }, { type : jsPsychHtmlKeyboardResponse , stimulus : block2Targets [ 0 ]. target , choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a cat or a dog?</p> <p>If cat, press the left arrow key.</p> <p>If dog, press the right arrow key.</p> ` data : { // Here is where we specify that we should save the trial to Firestore save_trial : true , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. }, } ] }; timeline . push ( catDogTrials ); Adding a block of stimuli \u00b6 We just added one single stimulus. It would be really annoying to have to write all that code over and over just to add the next nine stimuli for this block. Luckily, jsPsych has timeline variables to make this easier. In fact, the hot dog vs. not hot dog block already uses this technology. Let's add the other dog vs. cat stimuli using timeline variables with random sampling. code only screencast Edit the catVsDogTrials in the src/index.js file so that it reads: src/index.js 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 const catDogTrials = { timeline : [ { type : jsPsychHtmlKeyboardResponse , stimulus : `<div style=\"font-size: 60px;\">+</div>` , choices : 'NO_KEYS' , trial_duration : 500 , }, { type : jsPsychHtmlKeyboardResponse , stimulus : jsPsych . timelineVariable ( 'target' ), choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a cat or a dog?</p> <p>If cat, press the left arrow key.</p> <p>If dog, press the right arrow key.</p> ` data : { // Here is where we specify that this trial is a test response trial task : 'test_response' , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. For example, start_time : config . startTime . toLocaleString ( 'PST' ), start_time_unix : config . startTime . getTime (), timezone : Intl . DateTimeFormat (). resolvedOptions (). timeZone , } } ], timeline_variables : block2Targets , sample : { type : 'without-replacement' , size : 10 , }, }; Ending the experiment \u00b6 We've added the second block of stimuli. Right now, the experiment abruptly ends after the last stimulus. It's a good idea to let your participants know that they've finished the experiment. Let's add one last trial telling the participant that they are done. code only screencast Add one more trial and push it to the timeline before the exit_fullscreen trial. src/index.js 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 const endTrial = { type : jsPsychHtmlKeyboardResponse , stimulus : '<p>Great job! Press any key to finish the assessment.</p>' , choices : 'ALL_KEYS' , response_ends_trial : true , }; timeline . push ( endTrial ); const exit_fullscreen = { type : jsPsychFullScreen , fullscreen_mode : false , delay_after : 0 , }; timeline . push ( exit_fullscreen ); How to properly end your assessment Be sure to give your participant concrete instructions for how to end the assessment. In this case, we told them to \"press any key to finish the assessment.\" If you don't, then the participant might think that they are done and simply close the browser tab. Why is this bad? Although all of the trial information will be saved in the database, the assessment will not be counted as finished (either in the database or in the participant dashboard) because the jsPsych timeline did not complete. If you want to use any of jsPsych's audio plugins (e.g., audio-button-response or audio-keyboard-response ) to end the assessment be sure to specify trial_ends_after_audio: true so that the experiment automatically ends after the last audio file is played. Likewise, if you want to use any video plugins (e.g., video-button-response or video-keyboard-response ), be sure to specify trial_ends_after_video: true so that the experiment automatically ends after the last video. The guiding principle here is to ensure that the jsPsych timeline ends before the participant closes their browser tab. Advice for asset files \u00b6 Please see Common Issues > Advice For Asset Files .","title":"Writing Your Experiment"},{"location":"developer-guide/writing-your-experiment/#writing-your-experiment","text":"Finally, let's stimulate our participant!","title":"Writing your experiment"},{"location":"developer-guide/writing-your-experiment/#starting-the-development-server","text":"Your ROAR app is ready to go out of the box. Let's start the development server to see what the experiment looks like in the browser. code only screencast npm start This will automatically open a new browser tab with your experiment. It should look something like the experiment hosted here : However, you're experiment will automatically update when you make changes to your source code.","title":"Starting the development server"},{"location":"developer-guide/writing-your-experiment/#adding-another-block-of-stimuli","text":"Let's pretend that we want to add a new block to our experiment where we ask the participant to further differentiate between cats and dogs. Let's implement that structure now by first adding images of cats and dogs and then editing the experiment's source code to include those new images.","title":"Adding another block of stimuli"},{"location":"developer-guide/writing-your-experiment/#adding-more-images","text":"The first step in creating our new block is hosting the images of dogs and cats that we will use as stimuli. Download these images to your computer cat.zip dog.zip We will demonstrate two different ways to host images: we'll host the cat images along side your experiment and the dog images in a public google cloud storage bucket.","title":"Adding more images"},{"location":"developer-guide/writing-your-experiment/#hosting-images-alongside-your-experiment","text":"code only screencast First download the cat images zip file . Assuming that this file was downloaded to ~/Downloads , do # Make a folder for the cat images mkdir -p src/assets # Navigate to that folder cd src/assets # Move the downloaded zip file to this folder mv ~/Downloads/cat.zip . # Unzip the file unzip cat.zip # And delete the zip file rm cat.zip cd ../.. Now edit the src/loadAssets.js file to load these new cat images. You can add individual files simply by importing them as variables and then referencing them in your code. For example src/loadAssets.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import jsPsychPreload from '@jspsych/plugin-preload' ; import cat1 from './assets/cat/1.jpg' ; import cat2 from './assets/cat/2.jpg' ; import cat3 from './assets/cat/3.jpg' ; import cat4 from './assets/cat/4.jpg' ; import cat5 from './assets/cat/5.jpg' ; // Reference these files in a new array const catImages = [ cat1 , cat2 , cat3 , cat4 , cat5 ]; // Create arrays of hot dog / not hot dog images const numFiles = 5 ; const hotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/hotdog/ ${ idx } .jpg` , ); const notHotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/nothotdog/ ${ idx } .jpg` , ); const allFiles = hotDogFiles . concat ( notHotDogFiles ); export const allTargets = allFiles . map (( url ) => ({ target : `<img src=\" ${ url } \" width=250 height=250>` , isHotDog : ! url . includes ( 'nothotdog' ), })); /* preload images */ export const preloadImages = { type : jsPsychPreload , images : allFiles , }; // Preload the cat image export const preloadCatImages = { type : jsPsychPreload , images : catImages , } And don't forget to commit your changes into git. git add src/assets/cat git add -u git commit -m \"Add cat images for block 2\"","title":"Hosting images alongside your experiment"},{"location":"developer-guide/writing-your-experiment/#hosting-images-using-a-cloud-storage-provider","text":"The above method of hosting image assets alongside your experiment is fine if you only have a few files. But it can become cumbersome to import each file separately if you have a lot of assets. Rather than hosting your files with your website, you can upload them to a cloud storage provider and access your files using a URL. To demonstrate, we have already uploaded the dog images to a Google Cloud Storage bucket. In fact, it is the same bucket that already hosts the hot dog vs. not hot dog images. You can see the images here ( 1 , 2 , 3 , 4 , 5 ). Two popular cloud storage service providers are Google Cloud Storage (GCS) and Amazon Simple Storage Service (S3). To upload your own images and make them publicly available, follow these instructions: Create a storage bucket ( GCS instructions , S3 instructions ) Upload objects to the bucket ( GCS instructions , S3 instructions ) Make the data public ( GCS instructions , S3 instructions ) Then we can add references to the dog image URLs like so code only screencast Edit the src/loadAssets.js file to include the dog image URLs src/loadAssets.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import jsPsychPreload from '@jspsych/plugin-preload' ; import cat1 from './assets/cat/1.jpg' ; import cat2 from './assets/cat/2.jpg' ; import cat3 from './assets/cat/3.jpg' ; import cat4 from './assets/cat/4.jpg' ; import cat5 from './assets/cat/5.jpg' ; // Reference these files in a new array const catImages = [ cat1 , cat2 , cat3 , cat4 , cat5 ]; // Create arrays of hot dog / not hot dog images const numFiles = 5 ; const hotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/hotdog/ ${ idx } .jpg` , ); const notHotDogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/nothotdog/ ${ idx } .jpg` , ); const dogFiles = Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/dog/ ${ idx } .jpg` , ); const allFiles = hotDogFiles . concat ( notHotDogFiles ); export const allTargets = allFiles . map (( url ) => ({ target : `<img src=\" ${ url } \" width=250 height=250>` , isHotDog : ! url . includes ( 'nothotdog' ), })); /* preload images */ export const preloadImages = { type : jsPsychPreload , images : allFiles , }; const block2Files = catImages . concat ( dogFiles ); export const block2Targets = block2Files . map (( url ) => ({ target : `<img src=\" ${ url } \" width=250 height=250>` , isDog : url . includes ( 'dog' ), })); // Preload the cat/dog images export const preloadBlock2Images = { type : jsPsychPreload , images : block2Files , }; Making sense of the above javascript If the above line of javascript for dogFiles doesn't make sense to you, let's break it down into its components: Array ( numFiles ) // Yields [ <5 empty items> ] since numFiles = 5 Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ) // Yields [ 1, 2, 3, 4, 5 ] // And Finally Array . from ( Array ( numFiles ), ( _ , i ) => i + 1 ). map ( ( idx ) => `https://storage.googleapis.com/roar-hot-dog-images/dog/ ${ idx } .jpg` , ); // Yields // [ // 'https://storage.googleapis.com/roar-hot-dog-images/dog/1.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/2.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/3.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/4.jpg', // 'https://storage.googleapis.com/roar-hot-dog-images/dog/5.jpg' // ] By using the map method , we were able to write the URL pattern just once, following the DRY principle . We use the map method again to convert the raw URLs in the dogImages array to HTML image tags in the block2Targets array.","title":"Hosting images using a cloud storage provider"},{"location":"developer-guide/writing-your-experiment/#adding-a-block-of-stimuli-to-indexjs","text":"Now that we have established references to our new cat vs. dog images, let's create the new block of stimuli. We'll introduce this first by adding only one single stimulus. and then we'll use the same code to add an entire block of stimuli using jsPsych's timeline variables.","title":"Adding a block of stimuli to index.js"},{"location":"developer-guide/writing-your-experiment/#adding-a-single-stimulus","text":"We will add the first stimulus in the block2Targets array. code only screencast Edit the src/index.js file to include a new instruction set and the new stimuli. At the top of the file, add the following imports src/index.js 11 12 13 14 // Local modules import { initConfig , initRoarJsPsych , initRoarTimeline } from './config' ; import { allTargets , preloadImages , block2Targets , preloadBlock2Images } from './loadAssets' ; Then, a little bit later in the file, add src/index.js 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 timeline . push ( hotDogTrials ); const block2Instructions = { type : jsPsychHtmlKeyboardResponse , stimulus : ` <h3>Great Job!</h3> <p> Now press the right arrow key if the displayed image is of a dog. Press the left arrow key if the displayed image is of a cat. </p> <p>Press any key to continue.</p> ` , }; timeline . push ( preloadBlock2Images ); timeline . push ( block2Instructions ); const catDogTrials = { timeline : [ { type : jsPsychHtmlKeyboardResponse , stimulus : `<div style=\"font-size: 60px;\">+</div>` , choices : 'NO_KEYS' , trial_duration : 500 , }, { type : jsPsychHtmlKeyboardResponse , stimulus : block2Targets [ 0 ]. target , choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a cat or a dog?</p> <p>If cat, press the left arrow key.</p> <p>If dog, press the right arrow key.</p> ` data : { // Here is where we specify that we should save the trial to Firestore save_trial : true , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. }, } ] }; timeline . push ( catDogTrials );","title":"Adding a single stimulus"},{"location":"developer-guide/writing-your-experiment/#adding-a-block-of-stimuli","text":"We just added one single stimulus. It would be really annoying to have to write all that code over and over just to add the next nine stimuli for this block. Luckily, jsPsych has timeline variables to make this easier. In fact, the hot dog vs. not hot dog block already uses this technology. Let's add the other dog vs. cat stimuli using timeline variables with random sampling. code only screencast Edit the catVsDogTrials in the src/index.js file so that it reads: src/index.js 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 const catDogTrials = { timeline : [ { type : jsPsychHtmlKeyboardResponse , stimulus : `<div style=\"font-size: 60px;\">+</div>` , choices : 'NO_KEYS' , trial_duration : 500 , }, { type : jsPsychHtmlKeyboardResponse , stimulus : jsPsych . timelineVariable ( 'target' ), choices : [ 'ArrowLeft' , 'ArrowRight' ], prompt : ` <p>Is this a cat or a dog?</p> <p>If cat, press the left arrow key.</p> <p>If dog, press the right arrow key.</p> ` data : { // Here is where we specify that this trial is a test response trial task : 'test_response' , // Here we can also specify additional information that we would like stored // in this trial in ROAR's Firestore database. For example, start_time : config . startTime . toLocaleString ( 'PST' ), start_time_unix : config . startTime . getTime (), timezone : Intl . DateTimeFormat (). resolvedOptions (). timeZone , } } ], timeline_variables : block2Targets , sample : { type : 'without-replacement' , size : 10 , }, };","title":"Adding a block of stimuli"},{"location":"developer-guide/writing-your-experiment/#ending-the-experiment","text":"We've added the second block of stimuli. Right now, the experiment abruptly ends after the last stimulus. It's a good idea to let your participants know that they've finished the experiment. Let's add one last trial telling the participant that they are done. code only screencast Add one more trial and push it to the timeline before the exit_fullscreen trial. src/index.js 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 const endTrial = { type : jsPsychHtmlKeyboardResponse , stimulus : '<p>Great job! Press any key to finish the assessment.</p>' , choices : 'ALL_KEYS' , response_ends_trial : true , }; timeline . push ( endTrial ); const exit_fullscreen = { type : jsPsychFullScreen , fullscreen_mode : false , delay_after : 0 , }; timeline . push ( exit_fullscreen ); How to properly end your assessment Be sure to give your participant concrete instructions for how to end the assessment. In this case, we told them to \"press any key to finish the assessment.\" If you don't, then the participant might think that they are done and simply close the browser tab. Why is this bad? Although all of the trial information will be saved in the database, the assessment will not be counted as finished (either in the database or in the participant dashboard) because the jsPsych timeline did not complete. If you want to use any of jsPsych's audio plugins (e.g., audio-button-response or audio-keyboard-response ) to end the assessment be sure to specify trial_ends_after_audio: true so that the experiment automatically ends after the last audio file is played. Likewise, if you want to use any video plugins (e.g., video-button-response or video-keyboard-response ), be sure to specify trial_ends_after_video: true so that the experiment automatically ends after the last video. The guiding principle here is to ensure that the jsPsych timeline ends before the participant closes their browser tab.","title":"Ending the experiment"},{"location":"developer-guide/writing-your-experiment/#advice-for-asset-files","text":"Please see Common Issues > Advice For Asset Files .","title":"Advice for asset files"}]}